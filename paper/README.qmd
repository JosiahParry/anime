---
title: "ANIME: Approximate Network Integration, Matching, and Enrichment"

bibliography: refs.bib

author: 
  - name: Josiah Parry
    affiliation: Environmental Systems Research Institute, Redlands, CA, USA 
    orcid: 0000-0001-9910-865X
  - name: Zhao Wang
    affiliation: Leeds Institute for Transport Studies, University of Leeds, UK
    orcid: 0000-0002-4054-0533
  - name: Robin Lovelace
    affiliation: Leeds Institute for Transport Studies, University of Leeds, UK
    orcid: 0000-0001-5679-6536

format:
  pdf:
    include-in-header:
      text: |
        \usepackage{lineno}
        \linenumbers
        \usepackage{amsmath}
        \usepackage{algorithm}
        \usepackage{algpseudocode}
filters:
  - pseudocode
  
engine: knitr
number-sections: true
execute: 
  echo: false
  message: false
  warning: false
editor: 
  markdown: 
    wrap: sentence
---

```{r}
#| eval: false
if (!"quarto" %in% rownames(installed.packages())) {
  install.packages("quarto")
}
quarto::quarto_render("paper/README.qmd")
```


# Abstract {.unnumbered}

Reconciling topologically different linestrings is a fundamental challenge in spatial data science, particularly when integrating network datasets from disparate sources.
Existing methods often struggle with the absence of join keys and the need for wholesale joining of attributes, which hinders effective data integration and analysis.
This paper proposes a novel algorithm for matching two sets of linestrings, implemented in an open-source Rust library with bindings to R and Python.
The algorithm, Approximate Network Integration, Matching, and Enrichment (ANIME), addresses this challenge by identifying topologically similar linestrings and estimating the shared length between each pair of matched linestrings.
By leveraging R* spatial indices and angle-based matching criteria, the proposed approach effectively reconciles linestrings with varying topologies while supporting m:n correspondence relationships.
The system generates weighted relationship metrics, including shared length, source-weighted proportions, and target-weighted proportions, enabling both extensive and intensive interpolation methods for attribute transfer.
The flexibility, utility, and performance of ANIME are demonstrated in comparison with previous approaches.
Applications include transport planning, river network analysis, and ecological modeling, which require joins, weighted aggregations, and network subset identification based on shared characteristics.
The proposed algorithm offers a robust solution for reconciling linestrings in spatial datasets, with implications for various domains in spatial data science.

# Keywords {.unnumbered}

Network Conflation, Spatial Data Integration, Geometric Matching, Attribute Transfer, Spatial Interpolation

{{< pagebreak >}}

# Highlights {.unnumbered}

- A novel algorithm for matching topologically dissimilar linear network datasets.
- Implemented in a high-performance, open-source Rust library with R and Python bindings.
- Quantifies correspondence using shared length, supporting m:n relationships instead of binary classification.
- Enables both extensive and intensive attribute interpolation for numeric and categorical data.
- Leverages R*-tree spatial indexing and geometric criteria for efficient and robust matching.

{{< pagebreak >}}

# Introduction

A central challenge in transportation science is the reconciliation of vector-based linear network datasets from disparate sources, such as those from different government agencies, commercial providers, or time periods. These datasets often represent the same real-world phenomena but possess different underlying topologies and lack common join keys, precluding straightforward integration. The process of joining attributes between such networks: a critical component of the broader task of **conflation**, is further complicated by the fact that the attributes of one feature (e.g., speed limits, traffic volumes) are intended to be associated with its specific geometry, not transferred wholesale to another. Consequently, a weighted approach is necessary to properly associate attributes during integration. As noted by @lei_optimal_2019, "Due to the complexity and limitations of existing methods, planners and analysts often have to employ a heavily manual conflation process, which is time‐consuming and often prohibitively expensive."

The need for robust automated integration methods is growing as vast quantities of geospatial data are derived from sources like remotely sensed imagery (Samal et al., 2004) and large-scale feature extraction projects. While features from these sources may not be complete or entirely accurate, they can supplement missing data or reflect recent changes in a primary dataset, such as a master road network. Several persistent challenges, however, complicate the matching process. Matching generalized geometry to more detailed representations remains a largely unsolved problem (Kim et al., 2017; Mustiere & Devogele, 2008). Furthermore, a single real-world feature may be represented differently across datasets; for instance, a multi-lane highway could be a single line in one dataset and multiple, parallel lines in another ([@zhang_methods_nodate]). This leads to complex one-to-many or many-to-many correspondence scenarios. In the absence of reliable semantic information or join keys, a purely geometric approach becomes essential (Samal et al., 2004).

A vast body of literature addresses linestring matching, often framing it as a binary classification problem that determines whether a feature in a source dataset matches one in a target collection.
Given that a primary challenge lies in the absence of semantic information, these methods often rely on geometric criteria such as location (proximity), orientation (angle), length, and shape similarity (e.g., Fréchet or Hausdorff distance, or the average Euclidean distance between linestring vertices).
Numerous algorithms have been developed, each employing unique strategies.
For example, @goodchild_simple_1997 introduced a buffer-based algorithm that calculates the proportion of a source feature's length covered by a target feature.
Other notable approaches include the Java Conflation Suite (JCS) (FIXME: CITE JCS, 2003), the delimited strokes algorithm by @zhang_methods_nodate, the overline approach by Morgan and Lovelace (FIXME: CITE), and Esri's conflation toolset, which relies on buffer analysis and similarity metrics (FIXME: CITE Esri).
Kim et al. (2017) developed an algorithm to conflate historic and modern road networks using a C4.5 decision tree to classify matches based on spatial similarity measures, including the "linear directional mean" of line segments, the shorter line median Hausdorff distance (SMHD), and the absolute value of cosine similarity (aCS).
In contrast, some methods, such as the genetic algorithm proposed by @chehreghan_new_2017, are computationally expensive and do not scale well for large datasets.
A key limitation of all these methods is their focus on binary classification (a match or not), which fails to capture the partial overlaps endemic to real-world network data.

This paper introduces a new algorithm, Approximate Network Integration, Matching, and Enrichment (ANIME), that addresses these limitations. Instead of a binary classification, ANIME quantifies the degree of correspondence between networks, providing a more nuanced basis for data integration and attribute transfer. The main contributions of this work are:

1.  A novel algorithm that uses segment-level geometric criteria to match topologically dissimilar networks and quantify their shared length.
2.  A framework that supports `m:n` relationships and generates weighted metrics suitable for both extensive and intensive attribute interpolation.
3.  A high-performance, open-source implementation in Rust with bindings for R and Python, ensuring scalability and accessibility.

The remainder of this paper is organized as follows. Section 2 details the proposed methodology. Section 3 presents a case study applying ANIME to real-world road network data. Section 4 discusses the results and limitations of the approach. Finally, Section 5 provides concluding remarks and suggests directions for future research.

# Methodology

This section details the ANIME algorithm, from its conceptual foundation and geometric matching procedures to its methods for attribute integration and its implementation.

## Algorithm Overview

A key feature of the ANIME algorithm is its support for `m:n` correspondence, a departure from many existing algorithms that focus on 1:1 matching. Each feature in the target FeatureCollection can be matched to zero, one, or multiple features in the source FeatureCollection. The approach accommodates all relationship cardinalities, "including one-to-null, null-to-one, one-to-one, one-to-many, many-to-one, and many-to many" (Chehreghan & Abbaspour, 2017). Instead of providing a binary classification, the algorithm identifies potential matches and quantifies their correspondence, allowing for subsequent pruning if desired.

The proposed algorithm aims to match elements of two sets of LineStrings that are topologically similar and to estimate the amount of shared length between each pair of matched LineStrings. The result of the matching algorithm is a data structure (specifically, a B-Tree map) that contains the matched pairs and their shared lengths, which can be readily converted to a sparse matrix representation.

| Variable/Parameter           | Symbol    | Description                                                                    |
| ---------------------------- | --------- | ------------------------------------------------------------------------------ |
| Source features              | $A$       | The input `FeatureCollection` from which features are being matched.           |
| Target features              | $B$       | The input `FeatureCollection` to which features are being matched.             |
| Distance Tolerance           | $DT$      | The maximum distance for a line segment in B to search for matches in A.       |
| Angle Tolerance              | $AT$      | The maximum angle difference between two line segments to be considered parallel. |
| Shared Length                | $SL_{ij}$ | The length of overlap between a matched source feature $i$ and target feature $j$. |
| Source-weighted proportion | -         | The proportion of a source feature that is matched to a target feature.        |
| Target-weighted proportion | -         | The proportion of a target feature that is matched to a source feature.        |

: Summary of key variables and parameters. {#tbl-variables-parameters}


## Geometric Matching

The matching process is performed at the segment level to provide a granular assessment of correspondence. The process involves four main steps: linestring decomposition, spatial indexing to find candidates, geometric validation of candidates, and the calculation of overlap for validated matches.

### Linestring Decomposition
Each LineString in both the source and target datasets is broken down into its component Line segments. This decomposition allows for a granular analysis where matching is performed between individual segments rather than entire, complex features, which is essential for handling topological dissimilarity.

### Identify match candidates

To identify matches between $A$ and $B$ we do not look at the LineStrings in their totality, but rather, by their individual components. $A$ and $B$ are comprised of one or more LineStrings index by $i$ and $j$ respectively. Each linestring is composed of one or more lines indexed as $k$. Matches are found between elements of $A_{ik}$ and $B_{jk}$ using two R-trees. 

We create an empty R-tree, $Tree_A$. For each line $A_{ik}$ we compute the slope of the line and insert the geometry, slope, and index into the tree. 

Next we create another empty R-tree, $Tree_B$, in which we will store each line in $B_{jk}$. However, instead of using the axis-aligned bounding box of $B_{jk}$, we create a newer, larger one, based on a distance tolerance, $DT$. The distance tolerance is used to expand the search for matches. We compute the AABB of $B_{jk}$, then expand the AABB by $DT$ in both the x and y directions. After doing so, we insert the geometry, slope, and index into $Tree_B$

```{r message = FALSE, echo = FALSE}
#| layout-ncol: 2
suppressMessages(library(sf))
library(rsgeo)
library(ggplot2)
library(patchwork)
conflicted::conflict_prefer("ggplot2", "rsgeo")

# box to crop geometry to
crop_box <- st_bbox(c("xmin" = 427200, xmax = 427500, ymin = 433550, ymax = 433700))

rnet_x <- "https://raw.githubusercontent.com/nptscot/networkmerge/main/data/rnet_armley.geojson" |>
  read_sf() |>
  st_geometry() |>
  st_transform(27700) |>
  st_crop(crop_box)

rnet_y <- "https://raw.githubusercontent.com/nptscot/networkmerge/main/data/rnet_armley_line.geojson" |>
  read_sf() |>
  st_crop(crop_box)



x <- as_rsgeo(sf::st_transform(rnet_x, 27700))
y <- as_rsgeo(st_transform(rnet_y, 27700))

# axis-aligned-bounding-box for x
xbb <- bounding_rect(explode_lines(x))

# creating bounding rects for y
# need to expand them
ybb <- bounding_rect(explode_lines(y))

# define function to expand the AABB
expand_aabb <- function(x, DT) {
  crds <- coords(x)
  # xmin, max, max, min, min
  # ymin min max max min
  crds[, 1] <- crds[, 1] + (c(-1, 1, 1, -1, -1) * DT)
  crds[, 2] <- crds[, 2] + (c(-1, -1, 1, 1, -1) * DT)
  rsgeo::geom_polygon(crds$x, crds$y, crds$polygon_id)
}

DT <- 2.5
xbb_sf <- st_as_sfc(xbb) |> st_set_crs(27700)
ybb_sf <- st_as_sfc(expand_aabb(ybb, DT)) |> st_set_crs(27700)

p1 <- ggplot() +
  geom_sf(
    data = xbb_sf,
    fill = "#76b5c5", alpha = 0.25, lwd = 0.1
  ) +
  geom_sf(data = rnet_x, lwd = 0.2) +
  labs(title = "Axis-aligned-bounding-boxes of A") +
  theme_void()


p2 <- ggplot() +
  geom_sf(
    data = ybb_sf,
    fill = "#e28743", alpha = 0.25, lwd = 0.1
  ) +
  geom_sf(data = rnet_y, alpha = 0.5) +
  labs(
    title = "Axis-aligned-bounding-boxes of B",
    subtitle = paste0(DT, "meter distance tolerance")
  ) +
  theme_void()

p3 <- ggplot() +
  geom_sf(
    data = xbb_sf,
    fill = "#76b5c5", alpha = 0.25, lwd = 0.1
  ) +
  geom_sf(
    data = ybb_sf,
    fill = "#e28743", alpha = 0.25, lwd = 0.1
  ) +
  geom_sf(data = rnet_x, alpha = 0.5, lwd = 0.15) +
  geom_sf(data = rnet_y, alpha = 0.5) +
  labs(title = "AABB and Networks Overlay") +
  theme_void()


p1
p2
```

If AABBs between $Tree_A$ and $Tree_B$ are intersecting, it means that that the lines $A_{ik}$ and $B_{jk}$ might be within $DT$ of each other and should be checked to see if they are considered matches. 

```{r}
p3
```

### Geometric Validation (Angle and Distance Tolerances)
Candidate matches identified through spatial indexing are further validated based on two geometric criteria: orientation and proximity.
A candidate pair of segments, $A_{ik}$ and $B_{jk}$, are considered a match only if they are approximately parallel and within the specified distance tolerance.
Parallelism is determined by comparing the absolute difference between the segments' angles against an angle tolerance, $AT$.
Proximity is confirmed by measuring the minimum separable distance between the segments and ensuring it is less than or equal to the distance tolerance, $DT$.

```{r}
#| fig-cap: "Matched lines with 15° angle tolerance and 2.5 meter distance tolerance."
mtx <- anime::anime(
  rnet_y,
  rnet_x,
  2.5,
  15
)
mtx_df <- as.data.frame(mtx)
i <- 4
ydx <- which(mtx_df$target_id == i)
xx <- rnet_x[i]
yy <- rnet_y$geometry[mtx_df$source_id[ydx]]

# plot the lines that we will measure
plot(xx, lty = 3)
plot(yy, add = TRUE)
```

Being confident that the $A_{ik}$ and $B_{jk}$ are roughly parallel (within the threshold set by the `angle_threshold` argument), we next need to determine if they are within the distance tolerance determined by $DT$. This is done by measuring the minimum separable distance between $A_{ik}$ and $B_{jk}$. If both conditions are satisfied, then the lines are matched. Following, the shared segment length must be calculated.

### Calculating segment overlap

Once two lines $A_{ik}$ and $B_{jk}$ have been determined to be matches, we need to evaluate how much overlap exists between the two lines. This overlap is defined by the segment length of $A_{ik}$ contained in the overlap in the x or y dimension between $A_{ik}$ or $B_{jk}$. 

Based on the angle of the line $A_{ik}$, $\theta_{A_{ik}}$, we either calculate the overlap in the line segments in either the x or y dimension. 

![](assets/line-seg-overlap-top.png)

### Attribute Integration
ANIME provides methods for transferring attributes between matched features, supporting both numeric and categorical data types using principles from areal weighted interpolation.

#### Extensive Numeric Attribute Integration

For extensive variables (e.g., counts), the value for a target feature $j$, $\hat{Y}_j$, is estimated by summing the contributions from all matching source features $i$. The contribution of each source feature is its value $Y_i$ weighted by the proportion of its length that is shared with the target feature.

$$
\hat{Y}_j = \sum_{i} \frac{SL_{ij}}{\text{length}(i)} \times Y_i \tag{1}
$$
 
For intensive variables (e.g., averages, rates), the value for a target feature $j$, $\hat{Y}_j$, is estimated as the weighted average of the values from all matching source features. The value of each source feature $Y_i$ is weighted by the proportion of the target feature's length that it shares.

$$
\hat{Y}_j = \frac{\sum_{i} (SL_{ij} \times Y_i)}{\sum_{i} SL_{ij}} \tag{2}
$$

#### Extensive Categorical Attribute Integration

For categorical variables, the same integration methods are applied.
First, the categorical variable is transformed into a set of binary dummy variables, one for each category.
For a category $k$, the dummy variable $Y_{ik}$ is 1 if source feature $i$ has category $k$, and 0 otherwise.

Equations (1) and (2) can then be used to integrate these dummy variables.
Applying the extensive integration method (Equation 1) to $Y_{ik}$ yields the total length-weighted "count" of a category transferred to the target feature.
Applying the intensive integration method (Equation 2) yields the proportion of the matched length of the target feature that corresponds to category $k$.

### Implementation

ANIME is implemented in Rust to ensure high performance, with bindings for R and Python to provide accessibility to a broad audience of data scientists. The core algorithm leverages the `rstar` crate for R*-tree spatial indexing. The pseudocode for the approximate network matching algorithm is presented below.

```pseudocode
#| label: alg-approx-net-matching
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true

\begin{algorithm}
\caption{Approximate Network Matching}
\begin{algorithmic}
\State // Initialize R-trees for LineString components in sets A and B
\Procedure{ApproxNetworkMatch}{$A, B, DT, AT$}
  \State $Tree_A \gets$ InitializeEmptyRTree()
  \For{each $A_{ik} \in A$}
    \State $slope_{A_{ik}} \gets$ ComputeSlope($A_{ik}$)
    \State InsertIntoRTree($Tree_A, i, A_{ik}, slope_{A_{ik}}$)
  \EndFor
  
  \State $Tree_B \gets$ InitializeEmptyRTree()
  \For{each $B_{jk} \in B$}
    \State $expandedAABB_{B_{jk}} \gets$ ExpandAABB($B_{jk}, DT$)
    \State InsertIntoRTree($Tree_B, j, B_{jk}, expandedAABB_{B_{jk}}$)
  \EndFor
  
  \State // Identify potential match candidates
  \For{each pair $(A_{ik}, B_{jk})$ with intersecting AABBs}
    \If{IsParallelish($slope_{A_{ik}}, slope_{B_{jk}}, AT$) and IsWithinDistance($A_{ik}, B_{jk}, DT$)}
      \State // Calculate shared segment length
      \State $overlapLength \gets$ CalculateOverlapLength($A_{ik}, B_{jk}$)
      \State // Store matched pair and overlap length
      \State StoreOrUpdateMatchedPair($A_{ik}, B_{jk}, overlapLength$)
    \EndIf
  \EndFor
  
  \State \Return MatchedPairs
\EndProcedure

\State // Helper functions
\Function{IsParallelish}{$slope_{A}, slope_{B}, AT$}
  \State $angle_A \gets \arctan(slope_{A})$
  \State $angle_B \gets \arctan(slope_{B})$
  \State \Return $(|angle_A - angle_B| \le AT)$
\EndFunction

\Function{IsWithinDistance}{$A_{ik}, B_{jk}, DT$}
  \State $minDistance \gets$ ComputeMinSeparableDistance($A_{ik}, B_{jk}$)
  \State \Return $(minDistance \le DT)$
\EndFunction

\Function{CalculateOverlapLength}{$A_{ik}, B_{jk}$}
  \State $\theta_{A_{ik}} \gets$ ComputeAngle($A_{ik}$)
  \If{$\theta_{A_{ik}} \le 45^\circ$}
    \State $overlapLength \gets$ CalculateXOverlap($A_{ik}, B_{jk}$)
  \Else
    \State $overlapLength \gets$ CalculateYOverlap($A_{ik}, B_{jk}$)
  \EndIf
  \State \Return $overlapLength$
\EndFunction
\end{algorithmic}
\end{algorithm}
```
## Case Study

The experimental setup involves matching the source network to the target network using ANIME.
The parameters for the matching process were selected to accommodate minor discrepancies in geometry between the datasets.
A `distance_tolerance` of 2.5 meters was used to define the search radius for candidate segments, and an `angle_tolerance` of 15 degrees was used to identify segments with a similar orientation.

```{r}
#| label: setup-case-study
#| include: false
suppressMessages(library(sf))
suppressMessages(library(dplyr))
suppressMessages(library(ggplot2))

# Load source and target data
crop_box <- st_bbox(c("xmin" = 427200, xmax = 427500, ymin = 433550, ymax = 433700))

target_sf <- "https://raw.githubusercontent.com/nptscot/networkmerge/main/data/rnet_armley.geojson" |>
  read_sf() |>
  st_geometry() |>
  st_transform(27700) |>
  st_crop(crop_box) |>
  st_sf()

source_sf <- "https://raw.githubusercontent.com/nptscot/networkmerge/main/data/rnet_armley_line.geojson" |>
  read_sf() |>
  st_crop(crop_box) |>
  st_transform(27700)

# Add attributes to the source data for integration
set.seed(123)
source_sf$speed_limit <- sample(c(20, 30, 40), nrow(source_sf), replace = TRUE)
source_sf$road_type <- sample(c("residential", "primary"), nrow(source_sf), replace = TRUE)
source_sf$source_id <- 1:nrow(source_sf)

# Run ANIME
match_matrix <- anime::anime(
  source_sf,
  target_sf,
  distance_tolerance = 2.5,
  angle_tolerance = 15
)

match_df <- as.data.frame(match_matrix)

# Perform attribute integration
match_df_attr <- merge(match_df, st_drop_geometry(source_sf), by = "source_id")

# Intensive numeric integration
intensive_numeric <- match_df_attr |>
  group_by(target_id) |>
  summarise(
    speed_limit_integrated = sum(shared_len * speed_limit) / sum(shared_len)
  )

# Intensive categorical integration
road_type_dummies <- model.matrix(~ road_type - 1, data = match_df_attr)
match_df_attr_dummies <- cbind(match_df_attr, road_type_dummies)

intensive_categorical <- match_df_attr_dummies |>
  group_by(target_id) |>
  summarise(
    residential_prop = sum(shared_len * road_typeresidential) / sum(shared_len),
    primary_prop = sum(shared_len * road_typeprimary) / sum(shared_len)
  )

# Combine results
target_sf$target_id <- 1:nrow(target_sf)
integrated_sf <- merge(target_sf, intensive_numeric, by = "target_id", all.x = TRUE)
integrated_sf <- merge(integrated_sf, intensive_categorical, by = "target_id", all.x = TRUE)
```

## Results

The results of the matching and attribute integration are presented below.
They demonstrate the algorithm's ability to handle m:n relationships and perform weighted attribute transfer.

### Matching Results

The matching process generated a sparse matrix detailing the shared length between every source and target feature pair.
The following table shows a sample of the match list, detailing the source and target feature IDs and the calculated shared length.
The visualization in @fig-plot-matches illustrates a one-to-many match, where one target feature is matched with multiple source features, highlighting ANIME's ability to identify complex correspondences.

```{r}
#| label: table-match-results
#| echo: false
knitr::kable(
  head(match_df),
  caption = "Sample of matched pairs with shared length."
)
```

```{r}
#| label: fig-plot-matches
#| fig-cap: "Example of a one-to-many match. One target feature (blue, dashed) is matched with multiple source features (red, solid)."
#| echo: false
i <- 4
target_feature <- target_sf[i,]
source_indices <- match_df$source_id[match_df$target_id == i]
source_features <- source_sf[source_indices,]

ggplot() +
  geom_sf(data = source_features, color = "red", linewidth = 1) +
  geom_sf(data = target_feature, linetype = "dashed", color = "blue", linewidth = 1.2) +
  labs(title = "One-to-Many Match Example") +
  theme_void()

```

### Attribute Integration Results

Using the match list, attributes from the source network were integrated onto the target network.
The `speed_limit` (numeric, intensive) and `road_type` (categorical) attributes were transferred.

For the intensive numeric attribute `speed_limit`, the value for each target feature was calculated as the shared-length weighted average of the `speed_limit` from all its matched source features, using Equation (2).

For the categorical attribute `road_type`, the proportion of each target feature corresponding to a specific road type was calculated using the intensive integration method from Equation (2).
The resulting table shows the integrated attributes for the first few target features.

```{r}
#| label: table-attribute-integration
#| echo: false
knitr::kable(
  head(st_drop_geometry(integrated_sf)),
  caption = "Target features with integrated attributes.",
  digits = 2
)
```


## Discussion

The case study demonstrates ANIME's ability to successfully match and integrate data between topologically dissimilar networks.
The results highlight the benefits of the algorithm's quantitative, m:n matching approach over traditional binary classification methods.

### Interpretation of Results

The matching results show that ANIME can identify correspondences even where features are not perfectly aligned, such as the one-to-many relationship shown in @fig-plot-matches.
The attribute integration demonstrates how data can be transferred in a nuanced way.
For example, a target feature that overlaps with multiple source roads having different speed limits will receive a weighted average speed limit, which is more realistic than assigning the value from a single, potentially arbitrary, 'best' match.
Similarly, the proportional representation of categorical attributes provides a richer understanding of the target network's composition.

### Technical Limitations and Scope

This algorithm operates within specific technical constraints that define its applicability.

**Geometric Constraints:**
- The algorithm is designed for $\Bbb{R}^2$ Euclidean space and does not currently support 3-dimensional or spherical coordinates.
Extending the principles to these domains is conceivable, but presents challenges in defining and calculating overlap regions and lengths.
- Input geometries must be in the same projected coordinate reference system and be spatially proximal.
The algorithm does not perform on-the-fly geometric transformations.

**Geometric Transformation Limitations:**
- The algorithm does not handle systematic geometry shifts or require affine transformations to align datasets (Lei & Lei, 2019).
Users must ensure that datasets are properly georeferenced and aligned before applying the matching algorithm.
- There is no automatic handling of scale differences between datasets, which may require preprocessing for datasets at significantly different scales.

**Performance Considerations:**
- While the R*-tree spatial indexing provides efficient candidate identification, performance scales with the complexity and density of the input networks.
- Memory usage increases with the number of line segments, particularly for highly detailed networks with many vertices.

### Applications and Use Cases

The flexibility of ANIME enables diverse applications across spatial data science domains.

**Transport Planning:**
- Integration of road networks from multiple sources for comprehensive transportation analysis.
- Conflation of historical and current road datasets for temporal analysis.
- Matching of planned versus existing infrastructure for impact assessment.

**River Network Analysis:**
- Reconciliation of hydrographic datasets from different mapping agencies.
- Integration of modeled and observed stream networks for ecological studies.
- Conflation of networks at different scales for multi-resolution analysis.

**Ecological Modeling:**
- Matching of habitat corridors from different data sources.
- Integration of species movement pathways with landscape features.
- Conflation of ecological networks for conservation planning.

**Infrastructure Management:**
- Utility network integration for comprehensive asset management.
- Conflation of as-built versus design datasets for infrastructure monitoring.
- Integration of sensor networks with physical infrastructure representations.

### Future Development Directions

Future work could extend the capabilities of the algorithm in several key areas.

**3D and Spherical Support:**
- Extension to 3-dimensional coordinate systems to incorporate elevation data.
- Development of spherical geometry support for global-scale network analysis.
- Integration with 3D city models and Building Information Modeling (BIM) systems.

**Enhanced Geometric Processing:**
- Implementation of additional shape similarity measures beyond angle-based matching.
- Support for curved linestring matching using advanced geometric algorithms.
- Integration of topology-aware matching for complex network structures.

**Performance Optimization:**
- Parallel processing capabilities for large-scale network conflation.
- Streaming algorithms for processing networks that exceed available memory.
- GPU acceleration for computationally intensive geometric operations.

## Conclusion

This paper presents ANIME (Approximate Network Integration, Matching, and Enrichment), a novel algorithm for matching and integrating linestring datasets from disparate sources.
The algorithm addresses fundamental challenges in spatial data science by providing a robust solution for reconciling topologically different networks without requiring semantic join keys.

Key contributions of this work include:

1.  **Flexible Matching Framework**: Support for m:n correspondence relationships that accommodate the complex realities of real-world network datasets.
2.  **Quantitative Relationship Metrics**: Generation of weighted measures (`shared_len`, `source_weighted`, `target_weighted`) that enable sophisticated attribute interpolation.
3.  **High-Performance Implementation**: A Rust-based core with R and Python bindings that leverages R*-tree spatial indexing for efficient processing.
4.  **Comprehensive Attribute Integration**: Support for both extensive and intensive interpolation methods for numeric and categorical attributes.

The algorithm's flexibility makes it applicable across diverse domains, including transport planning, river network analysis, ecological modeling, and infrastructure management.
By providing quantitative measures of correspondence rather than binary classifications, ANIME enables analysts to make informed decisions about data integration and quality assessment.

Future work will focus on extending the algorithm to support 3-dimensional and spherical coordinate systems, implementing additional geometric similarity measures, and developing performance optimizations for large-scale applications.
The open-source implementation ensures that the algorithm can be adapted and extended by the broader geospatial community.

ANIME represents a significant advancement in network conflation methodology, offering a practical and theoretically sound approach to one of the most persistent problems in spatial data integration.

------

 
### References

[@morgan_travel_2021]
[@rawlingson_overlaying_2015]
[@chehreghan_new_2017]
[@goodchild_simple_1997]
[@zhang_methods_nodate]
[@lei_optimal_2019]

::: {#refs}
:::
 

## System Architecture and Implementation

ANIME follows a multi-layered architecture with a high-performance Rust core and language-specific bindings designed for optimal performance and accessibility across the geospatial community.

### Core Components

The system is built around several key components:

-   **Rust Core Algorithm**: A high-performance implementation of the approximate network matching algorithm using R*-tree spatial indexing.
-   **R Package Bindings**: The primary interface, providing seamless integration with the R geospatial ecosystem through the `geoarrow`, `arrow`, and `wk` packages.
-   **Python Package Bindings**: A secondary interface for Python users, enabling integration with the broader Python geospatial stack.
-   **Spatial Indexing Engine**: An R*-tree implementation for efficient geometric queries and candidate identification.
-   **Geometric Processing**: Algorithms for linestring decomposition, slope calculation, and overlap measurement.

### Language Integration Strategy

The system uses a Rust-centric approach with language-specific bridge libraries that provide native interfaces while maintaining the performance benefits of the core Rust implementation.
The R bindings utilize `rextendr` for seamless Rust-R integration, while the Python bindings provide access to the same core functionality through appropriate Python interfaces.

### Dependencies and Technology Stack

**System Requirements:**
-   Cargo (the Rust package manager) for building the core algorithm.
-   R development tools for R package compilation.

**R Package Dependencies:**
-   `geoarrow`: For efficient columnar geometry processing via the GeoArrow specification.
-   `arrow`: For columnar data processing and memory management.
-   `nanoarrow`: For low-level Arrow operations to optimize performance.
-   `rlang`: Provides R language utilities and metaprogramming support.
-   `wk`: For well-known geometry handling and geometric primitive operations.

**Development Dependencies:**
-   `rextendr`: The R-Rust bridge for package development and compilation.
-   `geoarrow-r`: A remote dependency for geospatial Arrow support.

