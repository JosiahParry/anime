---
title: "ANIME: Approximate Network Integration, Matching, and Enrichment"

bibliography: refs.bib

author: 
  - name: Josiah Parry
    affiliation: Environmental Systems Research Institute, Redlands, CA, USA 
    orcid: 0000-0001-9910-865X
  - name: Zhao Wang
    affiliation: Leeds Institute for Transport Studies, University of Leeds, UK
    orcid: 0000-0002-4054-0533
  - name: Robin Lovelace
    affiliation: Leeds Institute for Transport Studies, University of Leeds, UK
    orcid: 0000-0001-5679-6536

format:
  pdf:
    include-in-header:
      text: |
        \usepackage{lineno}
        \linenumbers

engine: knitr
number-sections: true
execute: 
  echo: false
  message: false
  warning: false
editor: 
  markdown: 
    wrap: sentence
---

```{r}
#| eval: false
if (!"quarto" %in% rownames(installed.packages())) {
  install.packages("quarto")
}
quarto::quarto_render("paper/README.qmd")
```


# Abstract {.unnumbered}

Reconciling topologically different linestrings is a fundamental challenge in spatial data science, particularly when integrating network datasets from disparate sources.
Existing methods often struggle with the absence of join keys and the need for wholesale joining of attributes, which hinders effective data integration and analysis.
This paper proposes a novel algorithm for matching two sets of linestrings, implemented in an open-source Rust library with bindings to R and Python.
The algorithm, Approximate Network Integration, Matching, and Enrichment (ANIME), addresses this challenge by identifying topologically similar linestrings and estimating the shared length between each pair of matched linestrings.
By leveraging R* spatial indices and angle-based matching criteria, the proposed approach effectively reconciles linestrings with varying topologies while supporting m:n correspondence relationships.
The system generates weighted relationship metrics, including shared length, source-weighted proportions, and target-weighted proportions, enabling both extensive and intensive interpolation methods for attribute transfer.
The flexibility, utility, and performance of ANIME are demonstrated in comparison with previous approaches.
Applications include transport planning, river network analysis, and ecological modeling, which require joins, weighted aggregations, and network subset identification based on shared characteristics.
The proposed algorithm offers a robust solution for reconciling linestrings in spatial datasets, with implications for various domains in spatial data science.

# Keywords {.unnumbered}

Network Conflation, Spatial Data Integration, Geometric Matching, Attribute Transfer, Spatial Interpolation

{{< pagebreak >}}

# Highlights {.unnumbered}

- A novel algorithm for matching topologically dissimilar linear network datasets.
- Implemented in a high-performance, open-source Rust library with R and Python bindings.
- Quantifies correspondence using shared length, supporting m:n relationships instead of binary classification.
- Enables both extensive and intensive attribute interpolation for numeric and categorical data.
- Leverages R*-tree spatial indexing and geometric criteria for efficient and robust matching.

{{< pagebreak >}}

# Introduction {.unnumbered}

A central challenge in spatial data science is the reconciliation of vector-based linear network datasets from disparate sources.
These datasets often represent the same real-world phenomena but possess different underlying topologies and lack common join keys, precluding straightforward integration.
The process of joining attributes between such networks, known as conflation, is further complicated by the fact that the attributes of one feature are intended to be associated with its specific geometry, not transferred wholesale to another.
Consequently, a weighted approach is necessary to properly associate attributes during integration.

> "Due to the complexity and limitations of existing methods, planners and analysts often have to employ a heavily manual conflation process, which is time‐consuming and often prohibitively expensive." --- Lei & Lei (2019).

This paper introduces a novel method for the spatial interpolation of linear features, which uses approximate network matching to generate a list of strong candidate matches with a quantified measure of shared overlap.
The results can then be utilized for what is known as 'vertical conflation' through a variety of approaches.
The need for such methods is growing as vast quantities of geospatial data are derived from sources like remotely sensed imagery (Samal et al., 2004) and large-scale feature extraction projects, such as Google's Open Buildings initiative.
While features from these sources may not always be complete or entirely accurate, they can supplement missing data or reflect recent changes in a primary dataset.

Several persistent challenges complicate the matching process.
Matching generalized geometry to more detailed representations remains a largely unsolved problem, often discussed in the context of varying Levels of Detail (LoD) (Kim et al., 2017; Mustiere & Devogele, 2008; Zhang, 2009).
Furthermore, a single real-world feature may be represented differently across datasets; for instance, a multi-lane highway could be a single line in one dataset and multiple lines in another (Zhang, 2009).
This leads to complex correspondence scenarios, including one-to-one, one-to-many, many-to-one, or even no correspondence.
In the absence of reliable semantic information or join keys, a purely geometric approach becomes essential (Kim et al., 2017).
As Samal et al. (2004) note, a simple spatial overlay of two sources does not automatically reveal these complex correspondences.


## Definitions

This section provides clear and concise definitions for the terminology used to describe the algorithm.

For consistency, this work adopts the definitions of geometric primitives from the Simple Feature Access (SFA) standard.
The algorithm makes extensive use of **Line** and **LineString** geometric primitives.
A **Line** is defined by two **Points**, which are (x, y) coordinate pairs.
A **LineString** is composed of two or more Points, where "each consecutive pair of Points defines a Line segment" (FIXME: CITE SFA).
Each LineString is referred to as a **feature**, and an array of features is a **FeatureCollection** (FIXME: CITE GEOJSON).

The objective of the algorithm is to identify matches between two LineString FeatureCollections and measure the length of the overlap.
A **match** is a correspondence between features from separate FeatureCollections (@lei_optimal_2019).

Terminology for the two FeatureCollections is inconsistent in the literature.
For example, Zhang (@zhang_methods_nodate) uses the terms *reference* and *target*, while the Java Conflation Suite (JCS) uses *reference* and *subject* (FIXME: CITE JCS).

This work adopts the terms **source** and the **target**, following Comber and Zeng's work on areal interpolation (@comber_spatial_2019).
The source and target terminology is more common in relational database management systems (RDBMS) and the broader data science ecosystem.
The use of these terms reflects a shift towards the more general field of spatial data science.
The objective of the matching algorithm is to match features _from_ the source _to_ the target.
Typically, the target is a more detailed and established collection of features.

During the matching process, **candidate**s are identified.
A candidate is a source feature that _may_ correspond to a target feature.
If a candidate passes a series of geometric tests, it is deemed a match.
After matches are found, attributes from the source feature are often transferred to the target feature.
This process of attribute transfer is referred to as **integration** <!-- FIXME: CITE -->. 


## Existing algorithms 

A vast body of literature is dedicated to matching linestring features between datasets.
These methods can be broadly categorized as binary classification algorithms that determine whether a feature in a source FeatureCollection matches a feature in a target collection.
The classification is often based on geometric criteria, semantic information, or both.
Given that the primary challenge often lies in the absence of semantic information, the focus here is on matching based strictly on geometric criteria.
Common criteria include location (proximity), orientation (angle), length, and shape similarity (often measured by metrics such as Fréchet distance, Hausdorff distance, or the average Euclidean distance between linestring vertices).

Numerous algorithms have been developed, each employing unique strategies.
Goodchild and Hunter (1997) introduced a buffer-based algorithm that calculates the proportion of a source feature's length covered by a target feature.
They state that:

> a similar approach based on the percentage of the reference source length rather than the tested source might be more related to generalization...

The algorithm presented here, through its reporting of shared overlap, allows for an adaptation of the Goodchild and Hunter method, using a percentage of source length overlap as a cutoff threshold.
However, a potential issue arises when a source feature is entirely contained within a target feature but the target extends well beyond it; this is addressed by leaning on principles of areal weighted interpolation.

Other notable approaches include the Java Conflation Suite (JCS) (FIXME: CITE JCS, 2003), the delimited strokes algorithm by Zhang (2009), the overline approach by Morgan and Lovelace (FIXME: CITE), and Esri's conflation toolset, which relies on buffer analysis and similarity metrics (FIXME: CITE Esri).
Kim et al. (2017) developed an algorithm to conflate historic and modern road networks using a C4.5 decision tree to classify matches based on spatial similarity measures.
These measures include the "linear directional mean" of line segments, the shorter line median Hausdorff distance (SMHD), and the absolute value of cosine similarity (aCS), the last of which is conceptually similar to the angle-based matching used in this work.
In contrast, some methods, such as the genetic algorithm proposed by Chehreghan & Abbaspour (2018), are computationally expensive and do not scale well for large datasets.
  

### Spatial Criteria 

The proposed algorithm can be understood as an extension of established buffer and orientation analysis techniques. It employs two primary spatial criteria:

- **Location/Proximity:** Measured using a distance tolerance that functions as a search buffer.
- **Orientation:** Measured by the angle between line segments.

The primary point of departure from many existing methods lies in the treatment of length. Most algorithms perform matching based on a holistic measure of similarity between entire LineStrings, such as the average Euclidean, Hausdorff, or Fréchet distance. These metrics evaluate the linestrings in their entirety and are subsequently used to make a binary classification of whether a pair is a match. In contrast, the ANIME algorithm decomposes linestrings into their constituent segments and calculates the actual length of overlap between corresponding segments, rather than using a summary distance metric for the entire features. This approach avoids a binary classification in favor of producing a quantitative measure of correspondence.

## Algorithm overview 

> "a good matching algorithm should be able to create high quality results at a high speed." --- (Zhang, 2009)

A key feature of the ANIME algorithm is its support for `m:n` correspondence, a departure from many existing algorithms that focus on 1:1 matching. Each feature in the target FeatureCollection can be matched to zero, one, or multiple features in the source FeatureCollection. The approach accommodates all relationship cardinalities, "including one-to-null, null-to-one, one-to-one, one-to-many, many-to-one, and many-to many" (Chehreghan & Abbaspour, 2017). As Lei & Lei (2019) note:
   
> Beyond the one‐to‐one case, however, matching becomes more complicated and less well‐defined.
   
Instead of providing a binary classification, the algorithm identifies potential matches and quantifies their correspondence, allowing for subsequent pruning if desired.

The proposed algorithm aims to match elements of two sets of LineStrings that are topologically similar and to estimate the amount of shared length between each pair of matched LineStrings.

Each LineString is decomposed into its constituent Line segments. The approximate network matching algorithm then constructs two R*-trees, one for the segments of the source features ($A$) and one for the target features ($B$). Intersections between the spatial indices of the two trees identify candidate pairs, limiting the search space. For each candidate pair, the angles of the line segments are compared to determine if they are approximately parallel (a state referred to as 'parallelish'). If the segments are approximately parallel and are within a specified minimum separable distance, they are considered a match. The overlapping portion of the matched segments is then used to compute the shared length.

The result of the matching algorithm is a data structure (specifically, a B-Tree map) that contains the matched pairs and their shared lengths, which can be readily converted to a sparse matrix representation.

| Variable/Parameter           | Symbol    | Description                                                                    |
| ---------------------------- | --------- | ------------------------------------------------------------------------------ |
| Source features              | $A$       | The input `FeatureCollection` from which features are being matched.           |
| Target features              | $B$       | The input `FeatureCollection` to which features are being matched.             |
| Distance Tolerance           | $DT$      | The maximum distance for a line segment in B to search for matches in A.       |
| Angle Tolerance              | $AT$      | The maximum angle difference between two line segments to be considered parallel. |
| Shared Length                | $SL_{ij}$ | The length of overlap between a matched source feature $i$ and target feature $j$. |
| Source-weighted proportion | -         | The proportion of a source feature that is matched to a target feature.        |
| Target-weighted proportion | -         | The proportion of a target feature that is matched to a source feature.        |

: Summary of key variables and parameters. {#tbl-variables-parameters}



### Data Processing Pipeline

ANIME processes linestring matching through a structured pipeline:

1.  **Data Preparation**: Source and target linestring datasets are loaded into appropriate geometric data structures.
2.  **Linestring Decomposition**: Each LineString is broken down into its component Line segments for granular analysis.
3.  **Spatial Indexing**: R* spatial indices are constructed for efficient geometric queries and candidate identification.
4.  **Candidate Identification**: The spatial index intersection is used to identify potential matches that are within the specified distance tolerance.
5.  **Geometric Validation**: Angle-based matching criteria are applied to filter candidates.
6.  **Overlap Calculation**: Shared segment lengths are computed for validated matches.
7.  **Result Generation**: Weighted relationship metrics and match tables are produced.

### Output Metrics and Relationship Quantification

The algorithm generates comprehensive weighted relationship metrics that quantify the correspondence between matched features:

| Metric           | Description                             | Range           | Purpose |
| ---------------- | --------------------------------------- | --------------- | ------- |
| `shared_len`     | Absolute shared length between features | 0 to max length | Quantifies overlap magnitude |
| `source_weighted`| Proportion of source feature matched    | 0.0 to 1.0+     | Measures source coverage |
| `target_weighted`| Proportion of target feature matched    | 0.0 to 1.0+     | Measures target coverage |

These metrics enable flexible analysis approaches:

-   **Complete Match Detection**: Indicated when both `source_weighted` and `target_weighted` approach 1.0.
-   **Partial Match Analysis**: Quantifying incomplete correspondences for use in weighted interpolation.
-   **Multi-Match Scenarios**: Handling cases where weighted values exceed 1.0 due to multiple overlapping matches.

### Configurable Matching Parameters

ANIME provides configurable tolerance parameters for geometric matching that allow users to adapt the algorithm to different data quality and precision requirements:

| Parameter           | Purpose                                        | Example Value | Impact |
| ------------------- | ---------------------------------------------- | ------------- | ------ |
| `distance_tolerance`| Maximum distance between linestrings           | 10 meters     | Controls spatial proximity requirements |
| `angle_tolerance`   | Maximum angle difference for parallel matching | 5 degrees     | Determines orientation similarity threshold |

### Identify match candidates

To identify matches between $A$ and $B$, the algorithm does not evaluate the LineStrings in their totality, but rather by their individual components. The sets $A$ and $B$ are comprised of one or more LineStrings, indexed by $i$ and $j$ respectively. Each LineString is composed of one or more lines, indexed as $k$. Matches are found between the segments $A_{ik}$ and $B_{jk}$ using two R*-trees. 

An empty R*-tree, $Tree_A$, is created. For each line segment $A_{ik}$, its slope is computed, and the geometry, slope, and index are inserted into the tree. 

Next, another empty R*-tree, $Tree_B$, is created to store each line in $B_{jk}$. However, instead of using the axis-aligned bounding box (AABB) of $B_{jk}$, a new, larger one is generated based on a distance tolerance, $DT$. This tolerance is used to expand the search space for matches. The AABB of $B_{jk}$ is computed and then expanded by $DT$ in both the x and y directions. Following this expansion, the geometry, slope, and index are inserted into $Tree_B$.

```{r message = FALSE, echo = FALSE}
#| layout-ncol: 2
suppressMessages(library(sf))
library(rsgeo)
library(ggplot2)
library(patchwork)
conflicted::conflict_prefer("ggplot2", "rsgeo")

# box to crop geometry to
crop_box <- st_bbox(c("xmin" = 427200, xmax = 427500, ymin = 433550, ymax = 433700))

rnet_x <- "https://raw.githubusercontent.com/nptscot/networkmerge/main/data/rnet_armley.geojson" |>
  read_sf() |>
  st_geometry() |>
  st_transform(27700) |>
  st_crop(crop_box)

rnet_y <- "https://raw.githubusercontent.com/nptscot/networkmerge/main/data/rnet_armley_line.geojson" |>
  read_sf() |>
  st_crop(crop_box)



x <- as_rsgeo(sf::st_transform(rnet_x, 27700))
y <- as_rsgeo(st_transform(rnet_y, 27700))

# axis-aligned-bounding-box for x
xbb <- bounding_rect(explode_lines(x))

# creating bounding rects for y
# need to expand them
ybb <- bounding_rect(explode_lines(y))

# define function to expand the AABB
expand_aabb <- function(x, DT) {
  crds <- coords(x)
  # xmin, max, max, min, min
  # ymin min max max min
  crds[, 1] <- crds[, 1] + (c(-1, 1, 1, -1, -1) * DT)
  crds[, 2] <- crds[, 2] + (c(-1, -1, 1, 1, -1) * DT)
  rsgeo::geom_polygon(crds$x, crds$y, crds$polygon_id)
}

DT <- 2.5
xbb_sf <- st_as_sfc(xbb) |> st_set_crs(27700)
ybb_sf <- st_as_sfc(expand_aabb(ybb, DT)) |> st_set_crs(27700)

p1 <- ggplot() +
  geom_sf(
    data = xbb_sf,
    fill = "#76b5c5", alpha = 0.25, lwd = 0.1
  ) +
  geom_sf(data = rnet_x, lwd = 0.2) +
  labs(title = "Axis-aligned-bounding-boxes of A") +
  theme_void()


p2 <- ggplot() +
  geom_sf(
    data = ybb_sf,
    fill = "#e28743", alpha = 0.25, lwd = 0.1
  ) +
  geom_sf(data = rnet_y, alpha = 0.5) +
  labs(
    title = "Axis-aligned-bounding-boxes of B",
    subtitle = paste0(DT, "meter distance tolerance")
  ) +
  theme_void()

p3 <- ggplot() +
  geom_sf(
    data = xbb_sf,
    fill = "#76b5c5", alpha = 0.25, lwd = 0.1
  ) +
  geom_sf(
    data = ybb_sf,
    fill = "#e28743", alpha = 0.25, lwd = 0.1
  ) +
  geom_sf(data = rnet_x, alpha = 0.5, lwd = 0.15) +
  geom_sf(data = rnet_y, alpha = 0.5) +
  labs(title = "AABB and Networks Overlay") +
  theme_void()


p1
p2
```


If the AABBs of segments from $Tree_A$ and $Tree_B$ intersect, it indicates that the lines $A_{ik}$ and $B_{jk}$ might be within the distance tolerance $DT$ of each other and should be evaluated as potential matches. 

```{r}
p3
```


### Matching Criteria 

Candidate matches, as determined by intersecting AABBs, must be further evaluated. To be considered a match, lines $A_{ik}$ and $B_{jk}$ must be approximately parallel (or 'parallelish'). To this end, an angle tolerance, $AT$, is defined. The inverse tangent of the slopes of lines $A_{ik}$ and $B_{jk}$ is taken to find their respective angles. If the absolute difference between these two angles is less than or equal to $AT$, they are deemed tolerant, or parallelish.

```{r}
#| fig-cap: "Matched lines with 15° angle tolerance and 2.5 meter distance tolerance."
mtx <- anime::anime(
  rnet_y,
  rnet_x,
  2.5,
  15
)
mtx_df <- as.data.frame(mtx)
i <- 4
ydx <- which(mtx_df$target_id == i)
xx <- rnet_x[i]
yy <- rnet_y$geometry[mtx_df$source_id[ydx]]

# plot the lines that we will measure
plot(xx, lty = 3)
plot(yy, add = TRUE)
```

Once it is confirmed that $A_{ik}$ and $B_{jk}$ are roughly parallel (within the threshold set by the `angle_threshold` argument), the next step is to determine if they are within the distance tolerance $DT$. This is accomplished by measuring the minimum separable distance between $A_{ik}$ and $B_{jk}$. If both the angle and distance conditions are satisfied, the lines are matched. Subsequently, the shared segment length is calculated.

### Calculating segment overlap 

Once two line segments $A_{ik}$ and $B_{jk}$ have been determined to be a match, the extent of their overlap must be calculated. This overlap is defined by projecting the segments onto an axis and measuring the length of their common interval.

Based on the angle of the line $A_{ik}$, $\theta_{A_{ik}}$, the overlap is calculated in either the x or y dimension. 

![](assets/line-seg-overlap-top.png)

If $\theta_{A_{ik}} \le 45^{\circ}$, the overlap is calculated between the projected intervals of $A_{ik}$ and $B_{jk}$ on the x-axis. The length of this overlapping interval is then used with the slope of $A_{ik}$ to determine the corresponding length along the segment itself. If $\theta_{A_{ik}} > 45^{\circ}$, the same procedure is applied using the y-axis. If there is no overlap in the projected dimension, the shared length is zero, even if both matching criteria were met.


## Algorithm Implementation 

```pseudocode
#| label: alg-approx-net-matching
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true

\begin{algorithm}
\caption{Approximate Network Matching}
\begin{algorithmic}
\State // Initialize R-trees for LineString components in sets A and B
\Procedure{ApproxNetworkMatch}{$A, B, DT, AT$}
  \State $Tree_A \gets$ InitializeEmptyRTree()
  \For{each $A_{ik} \in A$}
    \State $slope_{A_{ik}} \gets$ ComputeSlope($A_{ik}$)
    \State InsertIntoRTree($Tree_A, i, A_{ik}, slope_{A_{ik}}$)
  \EndFor
  
  \State $Tree_B \gets$ InitializeEmptyRTree()
  \For{each $B_{jk} \in B$}
    \State $AABB_{B_{jk}} \gets$ GetAABB($B_{jk}$)
    \State $expandedAABB_{B_{jk}} \gets$ ExpandAABB($AABB_{B_{jk}}, DT$)
    \State $slope_{B_{jk}} \gets$ ComputeSlope($B_{jk}$)
    \State InsertIntoRTree($Tree_B, j, B_{jk}, expandedAABB_{B_{jk}}, slope_{B_{jk}}$)
  \EndFor
  
  \State $MatchedPairs \gets$ InitializeEmptyCollection()
  \State // Identify potential match candidates by intersecting R-trees
  \For{each pair $(A_{ik}, B_{jk})$ where AABB of $A_{ik}$ intersects $expandedAABB_{B_{jk}}$}
    \If{IsParallelish($slope_{A_{ik}}, slope_{B_{jk}}, AT$) and IsWithinDistance($A_{ik}, B_{jk}, DT$)}
      \State // Calculate shared segment length
      \State $overlapLength \gets$ CalculateOverlapLength($A_{ik}, B_{jk}$)
      \If{$overlapLength > 0$}
        \State // Store matched pair and overlap length
        \State StoreOrUpdateMatchedPair($MatchedPairs, A_i, B_j, overlapLength$)
      \EndIf
    \EndIf
  \EndFor
  
  \State \Return MatchedPairs
\EndProcedure

\State // Helper functions
\Function{IsParallelish}{$slope_{A}, slope_{B}, AT$}
  \State $angle_A \gets \arctan(slope_{A})$
  \State $angle_B \gets \arctan(slope_{B})$
  \State \Return $(|angle_A - angle_B| \le AT)$
\EndFunction

\Function{IsWithinDistance}{$A_{ik}, B_{jk}, DT$}
  \State $minDistance \gets$ ComputeMinSeparableDistance($A_{ik}, B_{jk}$)
  \State \Return $(minDistance \le DT)$
\EndFunction

\Function{CalculateOverlapLength}{$A_{ik}, B_{jk}$}
  \State $\theta_{A_{ik}} \gets$ ComputeAngle($A_{ik}$)
  \If{$\theta_{A_{ik}} \le 45^\circ$}
    \State $overlapLength \gets$ CalculateXOverlapAndLength($A_{ik}, B_{jk}$)
  \Else
    \State $overlapLength \gets$ CalculateYOverlapAndLength($A_{ik}, B_{jk}$)
  \EndIf
  \State \Return $overlapLength$
\EndFunction
\end{algorithmic}
\end{algorithm}

```

## Integration of Numeric Attributes


This work integrates principles from areal weighted interpolation and geometric conflation to provide an algorithm that not only matches geometries but also performs attribute interpolation for both complete and partial matches.
By de-emphasizing the importance of exact 1:1 matches and relying on principles of spatial interpolation, it is possible to integrate datasets that are not representations of identical phenomena but rather similar ones. This effectively removes the emphasis on measures of fit.

In cases where a complete match is identified, the process amounts to a 1:1 attribute transfer.
For partial matches, intensive and extensive attribute transfer methods are employed (FIXME: CITE r-spatial book and Tobler/pysal).
Note that the total shared length between a source feature $i$ and a target feature $j$ may exceed the length of either feature.
This occurs when multiple segments of one feature match to segments of the other, a common scenario for parallel or winding geometries.
 
 
### Extensive Numeric Attribute Integration

Let the shared length between target $j$ and source $i$ be the variable $SL_{ij}$. The value of an extensive variable $\hat{Y}$ for a target feature $j$, $\hat{Y}_j$, is estimated by summing the contributions from all matching source features $i$. The contribution of each source feature is its value $Y_i$ weighted by the proportion of its length that is shared with the target feature.

$$
\hat{Y}_j = \sum_{i} \frac{SL_{ij}}{\text{length}(i)} \times Y_i
$$
 

### Intensive Numeric Attribute Integration

For an intensive variable, the value for a target feature $j$, $\hat{Y}_j$, is estimated as the weighted average of the values from all matching source features. The value of each source feature $Y_i$ is weighted by the proportion of the target feature's length that it shares.

$$
\hat{Y}_j = \frac{\sum_{i} (SL_{ij} \times Y_i)}{\sum_{i} SL_{ij}}
$$
 
## Integration of Categorical Attributes

A similar approach can be applied to categorical variables. Consider a categorical variable $Y$ with $k$ unique values. For each target feature $j$, a frequency table for each category $Y_k$ is calculated based on the matching source features. New numeric variables are created for each unique category $Y_k$, where the value for a source feature $i$ represents the presence (1) or absence (0) of that category. The extensive and intensive attribute integration methods can then be applied to these new dummy variables. 


### Extensive Categorical Attribute Integration 

The estimated value for a category $k$ on a target feature $j$, $\hat{Y}_{jk}$, is the sum of the shared length proportions from all source features that possess that category. $Y_{ik}$ is a binary indicator (1 if source feature $i$ has category $k$, 0 otherwise). This can be interpreted as the total length-weighted "count" of a category transferred to the target feature.
 
$$
\hat{Y}_{jk} = \sum_{i}{\frac{SL_{ij}}{\text{length}(i)}} \times Y_{ik}
$$

### Intensive Categorical Attribute Integration

The estimated value for a category $k$ on a target feature $j$, $\hat{Y}_{jk}$, is the shared-length weighted average of the presence of that category among source features. This yields the proportion of the matched length of the target feature that corresponds to a specific category.

$$
\hat{Y}_{jk} = \frac{\sum_{i} (SL_{ij} \times Y_{ik})}{\sum_{i} SL_{ij}}
$$
 
## Adaptability of Approximate Network Matching 

The proposed algorithm is highly flexible. For example, it can match features that have no direct overlap but are within the specified distance tolerance and meet the orientation criteria, which is useful for identifying adjacent or abutting neighbors. The results can also be used to efficiently narrow down a set of candidate matches for subsequent manual verification or processing with more computationally expensive algorithms. Furthermore, the shared overlap metric can be used to implement a binary classification by applying a threshold, if required by the application.

### Sample Data Integration and Testing

The system includes example datasets for testing and demonstration, enabling users to evaluate the algorithm's performance on real-world data. These datasets represent common scenarios in network conflation, including:

- Road networks from different sources (e.g., OpenStreetMap vs. government transportation datasets).
- Networks with varying levels of detail and generalization.
- Datasets with different topological representations of the same underlying phenomena.

### Usage Workflow

The primary workflow involves a straightforward process that leverages the system's flexible API:

1.  **Data Loading**: Import source and target linestring datasets using appropriate geospatial data structures.
2.  **Parameter Configuration**: Set distance and angle tolerance parameters based on data characteristics and matching requirements.
3.  **Matching Execution**: Call the core `anime()` function with configured geometric tolerance parameters.
4.  **Result Extraction**: Obtain tabular match results with weighted metrics.
5.  **Attribute Integration**: Apply extensive or intensive interpolation methods for attribute transfer between matched network features.
6.  **Analysis and Validation**: Process weighted metrics for network enrichment and quality assessment.

The system supports both extensive (additive) and intensive (average) interpolation methods for attribute transfer between matched network features, providing flexibility for different analytical requirements.

## Discussion

### Technical Limitations and Scope

This algorithm operates within specific technical constraints that define its applicability.

**Geometric Constraints:**
- The algorithm is designed for $\Bbb{R}^2$ Euclidean space and does not currently support 3-dimensional or spherical coordinates. Extending the principles to these domains is conceivable, but presents challenges in defining and calculating overlap regions and lengths.
- Input geometries must be in the same projected coordinate reference system and be spatially proximal. The algorithm does not perform on-the-fly geometric transformations.

**Geometric Transformation Limitations:**
- The algorithm does not handle systematic geometry shifts or require affine transformations to align datasets (Lei & Lei, 2019). Users must ensure that datasets are properly georeferenced and aligned before applying the matching algorithm.
- There is no automatic handling of scale differences between datasets, which may require preprocessing for datasets at significantly different scales.

**Performance Considerations:**
- While the R*-tree spatial indexing provides efficient candidate identification, performance scales with the complexity and density of the input networks.
- Memory usage increases with the number of line segments, particularly for highly detailed networks with many vertices.

### Applications and Use Cases

The flexibility of ANIME enables diverse applications across spatial data science domains.

**Transport Planning:**
- Integration of road networks from multiple sources for comprehensive transportation analysis.
- Conflation of historical and current road datasets for temporal analysis.
- Matching of planned versus existing infrastructure for impact assessment.

**River Network Analysis:**
- Reconciliation of hydrographic datasets from different mapping agencies.
- Integration of modeled and observed stream networks for ecological studies.
- Conflation of networks at different scales for multi-resolution analysis.

**Ecological Modeling:**
- Matching of habitat corridors from different data sources.
- Integration of species movement pathways with landscape features.
- Conflation of ecological networks for conservation planning.

**Infrastructure Management:**
- Utility network integration for comprehensive asset management.
- Conflation of as-built versus design datasets for infrastructure monitoring.
- Integration of sensor networks with physical infrastructure representations.

### Future Development Directions

Future work could extend the capabilities of the algorithm in several key areas.

**3D and Spherical Support:**
- Extension to 3-dimensional coordinate systems to incorporate elevation data.
- Development of spherical geometry support for global-scale network analysis.
- Integration with 3D city models and Building Information Modeling (BIM) systems.

**Enhanced Geometric Processing:**
- Implementation of additional shape similarity measures beyond angle-based matching.
- Support for curved linestring matching using advanced geometric algorithms.
- Integration of topology-aware matching for complex network structures.

**Performance Optimization:**
- Parallel processing capabilities for large-scale network conflation.
- Streaming algorithms for processing networks that exceed available memory.
- GPU acceleration for computationally intensive geometric operations.

## Conclusion

This paper presents ANIME (Approximate Network Integration, Matching, and Enrichment), a novel algorithm for matching and integrating linestring datasets from disparate sources.
The algorithm addresses fundamental challenges in spatial data science by providing a robust solution for reconciling topologically different networks without requiring semantic join keys.

Key contributions of this work include:

1.  **Flexible Matching Framework**: Support for m:n correspondence relationships that accommodate the complex realities of real-world network datasets.
2.  **Quantitative Relationship Metrics**: Generation of weighted measures (`shared_len`, `source_weighted`, `target_weighted`) that enable sophisticated attribute interpolation.
3.  **High-Performance Implementation**: A Rust-based core with R and Python bindings that leverages R*-tree spatial indexing for efficient processing.
4.  **Comprehensive Attribute Integration**: Support for both extensive and intensive interpolation methods for numeric and categorical attributes.

The algorithm's flexibility makes it applicable across diverse domains, including transport planning, river network analysis, ecological modeling, and infrastructure management.
By providing quantitative measures of correspondence rather than binary classifications, ANIME enables analysts to make informed decisions about data integration and quality assessment.

Future work will focus on extending the algorithm to support 3-dimensional and spherical coordinate systems, implementing additional geometric similarity measures, and developing performance optimizations for large-scale applications.
The open-source implementation ensures that the algorithm can be adapted and extended by the broader geospatial community.

ANIME represents a significant advancement in network conflation methodology, offering a practical and theoretically sound approach to one of the most persistent problems in spatial data integration.

------

 
### References

[@morgan_travel_2021]
[@rawlingson_overlaying_2015]
[@chehreghan_new_2017]
[@goodchild_simple_1997]
[@zhang_methods_nodate]
[@lei_optimal_2019]

::: {#refs}
:::
 

## System Architecture and Implementation

ANIME follows a multi-layered architecture with a high-performance Rust core and language-specific bindings designed for optimal performance and accessibility across the geospatial community.

### Core Components

The system is built around several key components:

-   **Rust Core Algorithm**: A high-performance implementation of the approximate network matching algorithm using R*-tree spatial indexing.
-   **R Package Bindings**: The primary interface, providing seamless integration with the R geospatial ecosystem through the `geoarrow`, `arrow`, and `wk` packages.
-   **Python Package Bindings**: A secondary interface for Python users, enabling integration with the broader Python geospatial stack.
-   **Spatial Indexing Engine**: An R*-tree implementation for efficient geometric queries and candidate identification.
-   **Geometric Processing**: Algorithms for linestring decomposition, slope calculation, and overlap measurement.

### Language Integration Strategy

The system uses a Rust-centric approach with language-specific bridge libraries that provide native interfaces while maintaining the performance benefits of the core Rust implementation.
The R bindings utilize `rextendr` for seamless Rust-R integration, while the Python bindings provide access to the same core functionality through appropriate Python interfaces.

### Dependencies and Technology Stack

**System Requirements:**
-   Cargo (the Rust package manager) for building the core algorithm.
-   R development tools for R package compilation.

**R Package Dependencies:**
-   `geoarrow`: For efficient columnar geometry processing via the GeoArrow specification.
-   `arrow`: For columnar data processing and memory management.
-   `nanoarrow`: For low-level Arrow operations to optimize performance.
-   `rlang`: Provides R language utilities and metaprogramming support.
-   `wk`: For well-known geometry handling and geometric primitive operations.

**Development Dependencies:**
-   `rextendr`: The R-Rust bridge for package development and compilation.
-   `geoarrow-r`: A remote dependency for geospatial Arrow support.

