---
title: "ANIME: Approximate Network Integration, Matching and Enrichment"

bibliography: refs.bib

author: 
  - name: Josiah Parry
    affiliation: Environmental Systems Research Institute, Redlands, CA, USA 
    orcid: 0000-0001-9910-865X
    email: josiah.parry@gmail.com
  - name: Zhao Wang
    affiliation: Leeds Institute for Transport Studies, University of Leeds, UK
    orcid: 0000-0002-4054-0533
    email: z.wang13@leeds.ac.uk
  - name: Robin Lovelace
    affiliation: Leeds Institute for Transport Studies, University of Leeds, UK
    orcid: 0000-0001-5679-6536
    email: r.lovelace@leeds.ac.uk

format:
  pdf:
    include-in-header:
      text: |
        \usepackage{lineno}
        \linenumbers
        \usepackage{amsmath}
        \usepackage{algorithm}
        \usepackage{algpseudocode}
        \usepackage{float}
filters:
  - pseudocode
  
engine: knitr
number-sections: true
execute: 
  echo: false
  message: false
  warning: false
editor: 
  markdown: 
    wrap: sentence
---


```{r}
#| eval: false
if (!"quarto" %in% rownames(installed.packages())) {
  install.packages("quarto")
}
quarto::quarto_render("paper/README.qmd")
```


# Abstract {.unnumbered}

Reconciling topologically different `LineString` geometries is a fundamental challenge in spatial data science, particularly when integrating `LineString` datasets representing spatial networks (roads, rivers, utilities) from disparate sources.
Existing methods can be limiting due to absence of join keys and the requirement of direct transfer of attributes.
This paper presents ANIME (Approximate Network Integration, Matching and Enrichment), a novel segment-level geometric matching algorithm implemented in a high-performance, open-source Rust library with bindings to R and Python.
ANIME quantifies the degree of correspondence between line geometries through shared length calculations, enabling robust handling of m:n relationships and complex topological dissimilarities.
The algorithm leverages R*-tree spatial indexing with angle and distance-based matching criteria, combined with overlap computation methods that adapt to line segment orientation.
The algorithm computes shared length ($SL_{ij}$) between corresponding features, providing the foundation for extensive and intensive attribute interpolation methods that enable statistically sound attribute transfer.
A case study on Scottish transport networks demonstrates effective handling of generalized-to-detailed geometry matching and multi-source attribute integration.
Applications span transport planning, hydrographic conflation, ecological modeling, and infrastructure management.

# Keywords {.unnumbered}

Network Conflation, Spatial Data Integration, Geometric Matching, Many-to-Many Matching, Attribute Interpolation, Linear Feature Matching, Open Source GIS

{{< pagebreak >}}

# Highlights {.unnumbered}

- A novel open-source segment-level algorithm for matching topologically dissimilar `LineString` datasets with mathematical rigor.
- High-performance implementation in Rust with comprehensive R and Python bindings for the geospatial research community.
- Quantitative correspondence measurement using shared length calculations, supporting m:n relationships instead of 1:1 or 1:m relationships.
- Mathematically grounded extensive and intensive attribute interpolation methods rooted in areal interpolation theory for both numeric and categorical data.

{{< pagebreak >}}

# Introduction

Reconciling vector `LineString` datasets from disparate sources remains a fundamental challenge in spatial data science.
Transport planning, in particular, increasingly requires the integration of multiple representations of linear networks, whether from government agencies, commercial providers, or crowd-sourced platforms, that depict the same real-world infrastructure yet differ in topology, geometry, and attribute schemas.
Throughout this paper, we use "network" to refer to spatial datasets composed of `LineString` geometries representing connected linear features—roads, rivers, pipelines, power lines, or any other infrastructure that can be modeled as collections of line segments.
Join keys are typically absent, making it unclear which features correspond between datasets.
Even when corresponding features can be identified, direct attribute transfer is often inappropriate: attributes such as speed limits or traffic volumes are associated with specific geometries that may lack direct counterparts in the target dataset.
A weighted approach is therefore necessary to accurately associate attributes during integration.
As @lei_optimal_2019 observed, "Due to the complexity and limitations of existing methods, planners and analysts often have to employ a heavily manual conflation^[Conflation is a two-step process that first identifies corresponding geometries between datasets and then transfers attributes between matched features.] process, which is time-consuming and often prohibitively expensive."

The need for robust automated integration methods is growing as vast quantities of geospatial data emerge from remotely sensed imagery and large-scale feature extraction projects.
These sources can supplement missing information and capture recent infrastructure changes, but they may be incomplete or geometrically imprecise.
Even mature crowd-sourced datasets such as OpenStreetMap exhibit substantial spatial variation in completeness and positional accuracy, with systematic urban–rural gradients [@li_osm_2025; @barrington_leigh_osm_2017].
Several persistent challenges complicate the matching process:

- matching generalized geometry to more detailed representations [@kim_conflation_2017; @mustiere_matching_2008];
- reconciling different representations of the same feature, such as a multi-lane highway depicted as a single line in one dataset and multiple parallel lines in another [@zhang_methods_nodate]; and
- addressing one-to-many or many-to-many correspondence scenarios where no simple bijective mapping exists.

In the absence of reliable semantic information or join keys, a purely geometric approach becomes essential [@samal_feature_2004].

## Existing approaches and limitations

Conflation, the process of aligning and integrating geospatial datasets, has been a subject of research for decades [@ruiz_digital_2011], with comprehensive surveys cataloguing the extensive range of similarity measures and matching algorithms developed for vector data [@xavier_survey_2016].
The literature predominantly frames network conflation as binary feature classification: determining whether a source feature matches a target feature based on geometric similarity measures such as proximity, orientation, length ratios, and shape metrics including Fréchet and Hausdorff distances [@samal_feature_2004].

### Traditional conflation methods

Early conflation methods established foundational approaches that remain influential today.
One of the first practical implementations is documented in the Java Conflation Suite (JCS) technical report [@davis_java_2003].
Buffer-based methods, exemplified by @goodchild_simple_1997, draw tolerance zones around features and measure overlap to calculate proportional coverage.
While pioneering, these approaches yield binary matching decisions, inside buffer equals match, outside equals non-match, and struggle with complex topological relationships.
Feature-based approaches [@samal_feature_2004; @mustiere_matching_2008] advanced the field by incorporating both geometric and topological properties, introducing partial (1:m or m:n) matches through combined bottom-up (local geometric) and top-down (global topological) procedures.
However, such methods often required manual intervention for complex split/merge scenarios, limiting their scalability.

### Recent algorithmic advances

Recent innovations have recast conflation as an optimization problem, seeking globally optimal match assignments rather than greedy pairwise decisions.
@lei_optimal_2019 developed a network flow-based approach that formulates matching as selecting flows (matches) that minimize total discrepancy, achieving match accuracy exceeding 95% while supporting partial matches through flow splitting.
This framework was extended by @lei_topological_2024 to incorporate topological constraints via an optimized node-arc conflation model, and by @wu_mincost_2022 through min-cost network flow relaxation that achieves optimal matching under geometric constraints.
Graph-based and multi-stage approaches have also emerged, leveraging spatial decomposition to manage complexity.
@nguyen_apsg_2022 introduced an area partitioning and subgraph growing (APSG) method that uses Voronoi diagrams to partition regions into localities, achieving F1-scores exceeding 0.9 by explicitly handling missing features and representation differences.
Similarly, @wu_voronoi_2023 proposed a Voronoi-based road network conflation method (VAMRN) that handles complex match cases (1:1, 1:n, m:n) by combining neighboring segments, improving F-scores by 4–30% while achieving 90% faster processing than probabilistic relaxation baselines.
At the production scale, @zhang_methodology_2023 demonstrated statewide road network conflation with approximately 99% match accuracy using intersection-based matching with fuzzy logic.

Beyond optimization and graph-based methods, other algorithmic approaches include the delimited strokes algorithm [@zhang_methods_nodate], the overline method for flow aggregation [@morgan_travel_2021], and commercial solutions such as Esri's conflation toolset [@esri_conflation_2023].
Recent work has also explored orientation-sensitive similarity measures, with @lei_turning_2021 demonstrating that turning function distance better differentiates road shapes than classic Hausdorff distance.
Machine learning approaches have attempted to automate classification decisions: @kim_conflation_2017 employed C4.5 decision trees using spatial similarity measures, while more recent deep learning approaches using graph neural networks show promise in identifying complex matching patterns across multi-scale datasets [@huang_gnn_2023].
Despite these advances, all such methods remain constrained by binary output frameworks that classify feature pairs as matched or unmatched.

### Comparative analysis of conflation methods

@tbl-comparison provides a systematic comparison of existing conflation methods across key dimensions relevant to practical network integration tasks.

| Method | Year | M:N Support | Output Type | Open Source | Attribute Transfer |
|--------|------|-------------|-------------|-------------|-------------------|
| Buffer Method [@goodchild_simple_1997] | 1997 | No (1:1) | Binary | N/A | No |
| Feature-based [@samal_feature_2004] | 2004 | Limited (1:m) | Binary | No | No |
| Delimited Strokes [@zhang_methods_nodate] | 2006 | No (1:1) | Binary | No | No |
| Network Flow [@lei_optimal_2019] | 2019 | Yes (m:n) | Flow values | No | Limited |
| Min-Cost Flow [@wu_mincost_2022] | 2022 | Yes (m:n) | Optimal pairs | No | No |
| APSG [@nguyen_apsg_2022] | 2022 | Yes (m:n) | Binary | No | No |
| Voronoi VAMRN [@wu_voronoi_2023] | 2023 | Yes (m:n) | Binary | No | No |
| GNN Pattern [@huang_gnn_2023] | 2023 | Yes (m:n) | Pattern labels | No | No |
| Esri Conflation [@esri_conflation_2023] | 2023 | Limited (1:m) | Similarity score | No | Yes |
| **ANIME (This work)** | **2025** | **Yes (m:n)** | **Shared length** | **Yes** | **Yes** |

: Comparison of network conflation methods. ANIME is distinguished by native m:n support, quantitative shared length output, open-source availability, and integrated attribute transfer capabilities. {#tbl-comparison}

As shown in @tbl-comparison, ANIME addresses key limitations of existing methods by providing: (1) native support for complex m:n relationships through segment-level decomposition, (2) quantitative correspondence measurement via shared length calculations rather than binary decisions, (3) open-source implementation ensuring reproducibility and community extensibility, and (4) mathematically grounded attribute transfer methods integrated directly into the conflation workflow.

### Spatial interpolation theory for attribute transfer

A notable gap in conflation research is the rigorous treatment of attribute transfer.
Transferring data such as traffic counts or road conditions from one network to another is fundamentally a spatial interpolation problem on linear features, yet most conflation methods treat it as a trivial post-processing step.
Classic areal interpolation theory provides essential guidance, distinguishing between extensive variables (e.g., counts, lengths) that must be apportioned proportionally and intensive variables (e.g., density, rates) that remain invariant to aggregation [@scheider_extensive_2019].
Recent synthesis across spatial data science languages emphasizes that attribute operations depend on support type (point vs. block) and on intensive versus extensive semantics, which constrains appropriate transfer during conflation [@pebesma_sdsl_2025].
This distinction is crucial for statistically valid attribute transfer during conflation.

@tobler_smooth_1979's pycnophylactic interpolation established the principle of mass conservation for areal data, ensuring that total extensive quantities are preserved during redistribution.
@goodchild_areal_1980 formalized areal interpolation in GIS, introducing area-weighted assumptions for transferring data between zoning systems.
More recent work by @comber_spatial_2019 provides a comprehensive review of interpolation techniques, distinguishing methods that use ancillary data (dasymetric mapping, street-weighted interpolation) from those that develop allocation procedures (pycnophylactic, areal weighting).
Notably, street-length weighting has emerged as an effective ancillary approach for distributing extensive variables along road networks.
@bentley_network_2013 demonstrated this principle by allocating population data to road networks using dasymetric techniques, directly bridging areal interpolation theory and linear features.
These principles provide the theoretical foundation for length-weighted attribute transfer in network conflation.

### Computational considerations

Network conflation is frequently required at city-to-national scales, where the dominant cost lies in generating and evaluating candidate correspondences between large sets of linear features.
Naive all-to-all comparisons quickly become intractable, so conflation pipelines typically separate a fast spatial filtering stage from more detailed geometric and topological checks.
Spatial indexing structures, most notably the R-tree [@guttman_rtrees_1984] and variants such as the R*-tree [@beckmann_rstartree_1990], support this filtering step by accelerating window and nearest-neighbor queries and thereby avoiding quadratic search.
Recent work continues to emphasize index-aware implementations for network operations, reporting substantial performance gains for spatial joins and nearest-neighbor search on road data [@kim_sgirtree_2024].
Complementary strategies further localize computation through partitioning and topology-aware divide-and-conquer, which is particularly important when many-to-many correspondences are admissible [@nguyen_apsg_2022; @wu_voronoi_2023].

### Multi-source data integration challenges

The computational constraints above are increasingly salient because road networks are now assembled from heterogeneous sources, ranging from authoritative mapping agencies to volunteered geographic information (VGI) platforms.
OpenStreetMap (OSM) provides global coverage and rapid updates, but its quality varies systematically across space and context.
Early evaluations found urban OSM roads within ~6 meters of UK Ordnance Survey data on average, while completeness and local accuracy were more variable [@haklay_good_2010].
Subsequent automated comparison frameworks have enabled systematic assessment of OSM against authoritative networks, documenting how partial overlaps, misalignment, and attribution differences complicate integration [@brovelli_osm_2016].
Although OSM has mapped a large share of the world’s road length, coverage remains uneven and data quality gradients persist between regions and settlement types [@barrington_leigh_osm_2017; @li_osm_2025].
These findings motivate conflation between crowd-sourced and official datasets: neither source is uniformly superior, and integration can improve completeness, positional reliability, and attribute richness relative to either dataset alone.
This practical need is reflected in applied transport planning workflows (e.g., the Propensity to Cycle Tool), which combine census inputs, survey data, and basemaps and therefore depend on robust cross-dataset alignment [@lovelace_propensity_2017].

### Reproducibility and open-source implementation

Methodological progress in conflation also depends on reproducible implementations.
Assessments of reproducibility in GIScience identify recurring barriers, including reliance on proprietary software, opaque parameterization, and workflows that are difficult to re-run or audit [@kedron_reproducibility_2021].
Recent calls for open geographic information science practices argue that sharing data, code, and executable workflows supports systematic comparison and cumulative improvement through community scrutiny and extension [@holler_open_2025].
However, many conflation methods remain either as academic prototypes or within closed toolchains (e.g., proprietary toolboxes), limiting independent evaluation and uptake.
This motivates conflation frameworks that are both methodologically explicit and distributed as accessible open-source software.

### Research gaps

Despite substantial methodological advances, four limitations recur across the conflation literature.
First, most techniques produce match sets or merged datasets without reporting correspondence measures that can be interpreted as proportional overlap; as a result, downstream analysis often treats matches as binary decisions rather than graded relationships.
Second, while recent optimization- and partitioning-based methods can represent many-to-many (M:N) correspondences [@lei_optimal_2019; @nguyen_apsg_2022], these capabilities are frequently obtained through complex modeling choices or post-hoc grouping, and partial matches are rarely treated as first-class outputs.
Third, attribute transfer is seldom grounded in spatial interpolation theory: once geometries are aligned, apportionment of extensive variables and treatment of intensive variables are often handled as ad hoc post-processing rather than as a core methodological step.
Fourth, reproducibility remains uneven because many methods are not distributed as usable, open implementations, limiting independent benchmarking and practical adoption.

Collectively, these limitations reflect an underlying tendency to frame conflation as a discrete matching problem, even though real-world networks exhibit partial and overlapping correspondences.
Without explicit quantification of overlap, it is difficult to propagate information across complex relationships and to perform statistically defensible, length-weighted attribute transfer.

## ANIME: A novel approach and research objectives

This paper presents ANIME (Approximate Network Integration, Matching and Enrichment), a fundamentally different approach to network conflation that abandons binary matching decisions in favor of **quantitative correspondence measurement**.
ANIME employs segment-level geometric analysis to quantify partial overlaps with mathematical rigor, enabling robust handling of complex topological relationships and providing a statistically sound foundation for weighted attribute transfer.

This work aims to address the limitations of existing methods through four primary research objectives:

1.  **Develop a quantitative correspondence framework** that measures degrees of geometric overlap rather than binary matching decisions, enabling precise representation of partial correspondences between `LineString` features.

2.  **Establish mathematical foundations** for weighted attribute transfer through rigorous geometric analysis and spatial interpolation theory.

3.  **Design and implement** a high-performance algorithmic solution that scales efficiently for large `LineString` datasets while maintaining broad accessibility across programming environments.

4.  **Validate the approach** through comprehensive testing on real-world transportation networks to demonstrate practical applicability and effectiveness.

The remainder of this paper is organized as follows.
Section 2 details the mathematical foundation and algorithmic methodology.
Section 3 presents the core implementation architecture and performance considerations.
Section 4 provides a comprehensive case study applying ANIME to real-world road network data.
Section 5 discusses results, limitations, and applications.
Finally, Section 6 provides concluding remarks and suggests directions for future research.

# Mathematical Foundation and Methodology

This section establishes the mathematical foundation of ANIME, which consists of two main components: (1) a core geometric matching algorithm that computes shared lengths between features, and (2) attribute interpolation methods that utilize these matching results for statistically sound attribute transfer.

## Mathematical framework

### Algorithm parameters

The ANIME matching algorithm operates on two sets of `LineString` features with algorithm parameters summarized in @tbl-variables-parameters.

| Variable/Parameter           | Symbol    | Description                                                                    |
| ---------------------------- | --------- | ------------------------------------------------------------------------------ |
| Source features              | $A$       | The input `FeatureCollection` from which attributes are transferred           |
| Target features              | $B$       | The input `FeatureCollection` to which features are being matched             |
| Distance Tolerance           | $DT$      | The maximum Euclidean distance for segment matching (in map units)            |
| Angle Tolerance              | $AT$      | The maximum angle difference (degrees) for parallel segment consideration     |

: Algorithm parameters for the ANIME matching procedure {#tbl-variables-parameters}


Each `LineString` in datasets $A$ and $B$ is formally decomposed into its component line segments:

- $A_{ik}$: The $k$-th line segment of the $i$-th `LineString` in source dataset $A$
- $B_{jk}$: The $k$-th line segment of the $j$-th `LineString` in target dataset $B$

The matching process is performed at the segment level to provide a granular assessment of correspondence.
This process involves five main steps:

1. **`LineString` decomposition**: Breaking down each `LineString` into constituent line segments
2. **AABB calculation and spatial indexing**: Computing bounding boxes and constructing R-trees for efficient spatial queries  
3. **Candidate identification**: Using spatial indexing to find potentially matching segment pairs
4. **Match selection**: Filtering candidates based on geometric constraints (angle and distance tolerances)
5. **Overlap calculation**: Computing shared length between confirmed matches

### Algorithm output structure

The ANIME matching algorithm produces a match matrix containing:
- Source feature lengths
- Target feature lengths  
- Match records with source indices, target indices, and shared lengths ($SL_{ij}$)

The output includes pre-computed weighted proportions for convenience:

- Source-weighted proportion: $sw_{ij} = SL_{ij} / \text{length}(i)$
- Target-weighted proportion: $tw_{ij} = SL_{ij} / \text{length}(j)$

This design separates the core geometric matching from subsequent attribute interpolation applications.

### `LineString` decomposition

`LineString` decomposition forms the foundational step that distinguishes ANIME from feature-level matching approaches. Each `LineString` geometry is systematically decomposed into its constituent line segments, enabling granular geometric analysis that is essential for handling complex topological relationships.

**Mathematical Definition**: For a `LineString` $L_i$ defined by an ordered sequence of vertices $\{v_1, v_2, \ldots, v_n\}$ where $v_k = (x_k, y_k)$, the decomposition yields $(n-1)$ line segments:

$$L_{i,k} = \overline{v_k v_{k+1}} \text{ for } k = 1, 2, \ldots, n-1 \tag{1}$$ {#eq-decomposition}

Each line segment $L_{i,k}$ is formally defined as the straight line connecting consecutive vertices $v_k$ and $v_{k+1}$, with geometric properties:

- **Length**: $|L_{i,k}| = \sqrt{(x_{k+1} - x_k)^2 + (y_{k+1} - y_k)^2}$
- **Slope**: $m_{i,k} = \frac{y_{k+1} - y_k}{x_{k+1} - x_k}$ (undefined for vertical segments)
- **Angle**: $\theta_{i,k} = \arctan(m_{i,k})$
- **Bounding Box**: $\text{AABB}_{i,k} = [\min(x_k, x_{k+1}), \max(x_k, x_{k+1})] \times [\min(y_k, y_{k+1}), \max(y_k, y_{k+1})]$

This segment-level decomposition provides several critical advantages over traditional feature-level matching:

1. **Topological Resilience**: Complex `LineString` features with different vertex densities or slight geometric variations can still be matched at the segment level, even when their overall shapes differ significantly.

2. **M:N Relationship Handling**: A single segment from one dataset can match multiple segments from another dataset, and vice versa, naturally accommodating the complex correspondence patterns common in real-world `LineString` data.

3. **Partial Overlap Quantification**: Rather than binary matching decisions (match/no-match), the algorithm can quantify the precise degree of correspondence between features through segment-level shared length calculations.

4. **Computational Efficiency**: Segment-level processing enables efficient spatial indexing and reduces the complexity of geometric computations compared to complex multi-vertex `LineString` comparisons.

The decomposition process preserves the relationship between segments and their parent `LineString` features through indexing schemes $A_{ik}$ and $B_{jk}$, where $i$ and $j$ represent `LineString` indices and $k$ represents segment indices within each `LineString`. This indexing structure is essential for subsequent attribute aggregation and ensures that the segment-level matching results can be properly aggregated back to the feature level.

The decomposed segments serve as the fundamental units for all subsequent processing steps: spatial indexing, candidate identification, geometric validation, and overlap calculation. This granular approach enables ANIME to handle the complex geometric relationships that characterize real-world network conflation scenarios.

### Spatial indexing and candidate identification

Matches between $A$ and $B$ are not identified by considering the `LineString` geometries in their totality, but rather by their individual components.
$A$ and $B$ are comprised of one or more `LineString` geometries, indexed by $i$ and $j$ respectively.
Each `LineString` is composed of one or more line segments, indexed by $k$.
Matches are found between line segments $A_{ik}$ and $B_{jk}$ using two R-trees.

An empty R-tree, $Tree_A$, is created.
For each line segment $A_{ik}$, its slope is computed, and the geometry, slope, and index are inserted into the tree.
Next, another empty R-tree, $Tree_B$, is created to store each line segment in $B_{jk}$.
Instead of using the axis-aligned bounding box (AABB) of $B_{jk}$, a larger one is created based on the distance tolerance, $DT$, which expands the search radius for matches.
The AABB of $B_{jk}$ is computed and then expanded by $DT$ in both the x and y directions, such that the expanded AABB is defined as $[x_{\min} - DT, x_{\max} + DT] \times [y_{\min} - DT, y_{\max} + DT]$.
After doing so, the geometry, slope, and index are inserted into $Tree_B$.

```{r message = FALSE, echo = FALSE}
#| label: fig-aabb-construction
#| fig-cap: "Spatial indexing construction for ANIME's R*-tree implementation. Left: Standard axis-aligned bounding boxes (AABBs) for source network A segments (blue boxes). Right: Distance-buffered AABBs for target network B segments (orange boxes) expanded by 2.5-meter tolerance to accommodate geometric search radius. "
suppressMessages(library(sf))
library(rsgeo)
library(ggplot2)
library(patchwork)
conflicted::conflict_prefer("ggplot2", "rsgeo")

# box to crop geometry to
crop_box <- st_bbox(c("xmin" = 427200, xmax = 427500, ymin = 433550, ymax = 433700))

rnet_x <- "https://raw.githubusercontent.com/nptscot/networkmerge/main/data/rnet_armley.geojson" |>
  read_sf() |>
  st_geometry() |>
  st_transform(27700) |>
  st_crop(crop_box)

rnet_y <- "https://raw.githubusercontent.com/nptscot/networkmerge/main/data/rnet_armley_line.geojson" |>
  read_sf() |>
  st_crop(crop_box)



x <- as_rsgeo(sf::st_transform(rnet_x, 27700))
y <- as_rsgeo(st_transform(rnet_y, 27700))

# axis-aligned-bounding-box for x
xbb <- bounding_rect(explode_lines(x))

# creating bounding rects for y
# need to expand them
ybb <- bounding_rect(explode_lines(y))

# define function to expand the AABB
expand_aabb <- function(x, DT) {
  crds <- coords(x)
  # xmin, max, max, min, min
  # ymin min max max min
  crds[, 1] <- crds[, 1] + (c(-1, 1, 1, -1, -1) * DT)
  crds[, 2] <- crds[, 2] + (c(-1, -1, 1, 1, -1) * DT)
  rsgeo::geom_polygon(crds$x, crds$y, crds$polygon_id)
}

DT <- 2.5
xbb_sf <- st_as_sfc(xbb) |> st_set_crs(27700)
ybb_sf <- st_as_sfc(expand_aabb(ybb, DT)) |> st_set_crs(27700)

p1_left <- ggplot() +
  geom_sf(
    data = xbb_sf,
    fill = "#76b5c5", alpha = 0.25, lwd = 0.1
  ) +
  geom_sf(data = rnet_x, lwd = 0.2) +
  labs(subtitle = "Source Network AABBs") +
  theme_void()

p1_right <- ggplot() +
  geom_sf(
    data = ybb_sf,
    fill = "#e28743", alpha = 0.25, lwd = 0.1
  ) +
  geom_sf(data = rnet_y, alpha = 0.5) +
  labs(subtitle = "Target Network Distance-Buffered AABBs") +
  theme_void()

p3 <- ggplot() +
  geom_sf(
    data = xbb_sf,
    fill = "#76b5c5", alpha = 0.25, lwd = 0.1
  ) +
  geom_sf(
    data = ybb_sf,
    fill = "#e28743", alpha = 0.25, lwd = 0.1
  ) +
  geom_sf(data = rnet_x, alpha = 0.5, lwd = 0.15) +
  geom_sf(data = rnet_y, alpha = 0.5) +
  theme_void()

# Display the two-panel figure as referenced in caption
p1_left + p1_right 
```

The spatial indexing construction is illustrated in @fig-aabb-construction.
@fig-aabb-construction (left) shows how axis-aligned bounding boxes (AABBs) are created for the source network, while @fig-aabb-construction (right)  shows that the target network features distance-buffered envelopes.
If the AABBs of segments from $Tree_A$ and $Tree_B$ intersect, it indicates that the line segments $A_{ik}$ and $B_{jk}$ may be within the distance tolerance $DT$ of each other and are thus candidates for matching.

The network overlay shown in @fig-network-overlay provides the spatial context for understanding potential match candidates, where intersecting bounding boxes indicate segment pairs that require geometric validation.


```{r}
#| label: fig-network-overlay
#| fig-cap: "Overlay of source network A (blue with bounding boxes) and target network B (red with distance-buffered bounding boxes), showing potential match candidates where bounding boxes intersect."
p3
```

### Geometric validation (angle and distance tolerances)
Candidate matches identified through spatial indexing are further validated based on two geometric criteria: orientation and proximity.
A candidate pair of segments, $A_{ik}$ and $B_{jk}$, is considered a match only if they are approximately parallel and within the specified distance tolerance.
Parallelism is determined by comparing the absolute difference between the segments' angles against an angle tolerance, $AT$.
The angle $\theta$ for a segment is calculated from its slope $m$ as $\theta = \arctan(m)$.
Two segments are considered parallel if $|\theta_{A_{ik}} - \theta_{B_{jk}}| \le AT$.
Proximity is confirmed by measuring the minimum separable distance between the segments and ensuring it is less than or equal to the distance tolerance, $DT$. 

Once it is determined that $A_{ik}$ and $B_{jk}$ are approximately parallel (within the threshold set by the `angle_tolerance` argument), the next step is to verify that they are within the distance tolerance $DT$.
This check is performed by measuring the minimum separable distance between $A_{ik}$ and $B_{jk}$.
If both conditions are satisfied, the segments are considered a match.@fig-geometric-validation demonstrates a geometric validation example by showing how source line segments (solid lines) are matched to target segments (dashed lines) within a 15° angular and 2.5-meter distance tolerance.

```{r}
#| label: fig-geometric-validation
#| fig-cap: "Geometric validation example showing source line segments (solid) matched to target segments (dashed) within 15° angular and 2.5m distance tolerance. Multiple source features correspond to a single target feature, demonstrating m:n relationship handling."
mtx <- anime::anime(
  rnet_y,
  rnet_x,
  2.5,
  15
)
mtx_df <- as.data.frame(mtx)
i <- 4
ydx <- which(mtx_df$target_id == i)
xx <- rnet_x[i]
yy <- rnet_y$geometry[mtx_df$source_id[ydx]]

# plot the lines that we will measure
ggplot() +
  geom_sf(data = yy) +
  geom_sf(data = xx, linetype = "dashed") +
  # labs(title = "Geometric Validation Example") +
  theme_void()
```


### Overlap calculation and shared length quantification

Once two line segments $A_{ik}$ and $B_{jk}$ are identified as a match, the extent of their overlap is calculated.
This overlap is defined as the length of the portion of segment $A_{ik}$ that is projected onto the overlapping range of either the x- or y-dimensions of the two segments.

The calculation of the overlap is performed in either the x or y dimension, depending on the angle of the line segment $A_{ik}$, $\theta_{A_{ik}}$. The shared segment length is calculated using the approach illustrated in @fig-segment-overlap. When multiple segment pairs from the same source-target feature pair match, their shared lengths are accumulated to produce the total shared length $SL_{ij}$ for that feature pair.

![Schematic illustration of segment overlap calculation. The shared length is determined by projecting line segments onto either the x-axis (for slopes ≤45°) or y-axis (for slopes >45°) and calculating the intersection of projected ranges.](assets/line-seg-overlap-top.png){#fig-segment-overlap}

## Attribute integration methods

While the core ANIME algorithm focuses solely on geometric matching and shared length computation, the resulting match matrix enables robust attribute transfer applications. The following methods utilize the computed shared lengths ($SL_{ij}$) for transferring attributes between matched features, supporting both numeric and categorical data types using principles from areal weighted interpolation.
Areal weighted interpolation is commonly used for extensive variables, where the value is dependent on the size of the area, like population counts [@comber_spatial_2019].
Intensive variables, which are independent of the area's size, such as population density or percentages, require a different approach.

**Numeric Attribute Integration**

For extensive variables (e.g., counts), the value for a target feature $j$, $\hat{Y}_j$, is estimated by summing the weighted values from all matching source features $i$.
The value of each source feature, $Y_i$, is weighted by the proportion of its length that is matched to target feature $j$.

$$
\hat{Y}_j = \sum_{i} \frac{SL_{ij}}{\text{length}(i)} \times Y_i \tag{2}
$$ {#eq-extensive}
 
For intensive variables (e.g., averages, rates), the value for a target feature $j$, $\hat{Y}_j$, is estimated as the weighted average of the values from all matching source features.
The value of each source feature $Y_i$ is weighted by the shared length of the match, $SL_{ij}$.^[The implementation normalizes weights by target length for numerical consistency: $w_{ij} = SL_{ij}/\text{length}(j)$. Since $\text{length}(j)$ appears in both numerator and denominator, the result is mathematically equivalent to Eq. 3.] Target features with no valid matches (i.e., $\sum_{i} SL_{ij} = 0$) receive a value of zero.

$$
\hat{Y}_j = \frac{\sum_{i} (SL_{ij} \times Y_i)}{\sum_{i} SL_{ij}} \tag{3}
$$ {#eq-intensive}

**Categorical Attribute Integration**

While the core ANIME algorithm does not directly handle categorical variables, client-side implementations can integrate them by first transforming them into numeric representations. A common approach is to convert a categorical variable into a set of binary dummy variables, one for each category. For a category $k$, the dummy variable $Y_{ik}$ is 1 if source feature $i$ has category $k$, and 0 otherwise.

@eq-extensive and @eq-intensive can then be used to integrate these dummy variables. Applying the extensive integration method (@eq-extensive) to $Y_{ik}$ yields the total length-weighted count of category $k$ transferred to the target feature. Applying the intensive integration method (@eq-intensive) yields the proportion of the matched length of the target feature that corresponds to category $k$. This approach is demonstrated in the R implementation.

# Core Implementation Architecture

This section details the high-performance implementation of ANIME, which is written in Rust to ensure performance and portability, with bindings for R and Python for broad accessibility. The core algorithm leverages the `rstar` crate for R*-tree spatial indexing and is outlined in the pseudocode below. The following subsections describe its architectural design, data structures, and optimization strategies.

```pseudocode
#| label: alg-approx-net-matching
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "H"
#| pdf-line-number: true

\begin{algorithm}
\caption{Approximate Network Matching}
\begin{algorithmic}
\State // Initialize R-trees for `LineString` components in sets A and B
\Procedure{ApproxNetworkMatch}{$A, B, DT, AT$}
  \State $Tree_A \gets$ InitializeEmptyRTree()
  \For{each $A_{ik} \in A$}
    \State $slope_{A_{ik}} \gets$ ComputeSlope($A_{ik}$)
    \State InsertIntoRTree($Tree_A, i, A_{ik}, slope_{A_{ik}}$)
  \EndFor
  
  \State $Tree_B \gets$ InitializeEmptyRTree()
  \For{each $B_{jk} \in B$}
    \State $expandedAABB_{B_{jk}} \gets$ ExpandAABB($B_{jk}, DT$)
    \State InsertIntoRTree($Tree_B, j, B_{jk}, expandedAABB_{B_{jk}}$)
  \EndFor
  
  \State // Identify potential match candidates from intersecting AABBs
  \State $Candidates \gets$ FindIntersectingPairs($Tree_A, Tree_B$)
  
  \For{each candidate pair $(A_{ik}, B_{jk}) \in Candidates$}
    \If{IsParallelWithinTolerance($slope_{A_{ik}}, slope_{B_{jk}}, AT$) and IsWithinDistance($A_{ik}, B_{jk}, DT$)}
      \State // Calculate shared segment length
      \State $overlapLength \gets$ CalculateOverlapLength($A_{ik}, B_{jk}$)
      \State // Store matched pair and shared length
      \State StoreOrUpdateMatch($i, j, overlapLength$)
    \EndIf
  \EndFor
  
  \State \Return MatchedPairs
\EndProcedure

\State // Helper functions
\Function{IsParallelWithinTolerance}{$slope_{A}, slope_{B}, AT$}
  \State $angle_A \gets \arctan(slope_{A})$
  \State $angle_B \gets \arctan(slope_{B})$
  \State \Return $(|angle_A - angle_B| < AT)$
\EndFunction

\Function{IsWithinDistance}{$A_{ik}, B_{jk}, DT$}
  \State $minDistance \gets$ ComputeMinSeparableDistance($A_{ik}, B_{jk}$)
  \State \Return $(minDistance \le DT)$
\EndFunction

\Function{CalculateOverlapLength}{$A_{ik}, B_{jk}$}
  \State $\theta_{A_{ik}} \gets$ ComputeAngle($A_{ik}$)
  \If{$\theta_{A_{ik}} \le 45^\circ$}
    \State $overlapLength \gets$ CalculateXOverlap($A_{ik}, B_{jk}$)
  \Else
    \State $overlapLength \gets$ CalculateYOverlap($A_{ik}, B_{jk}$)
  \EndIf
  \State \Return $overlapLength$
\EndFunction
\end{algorithmic}
\end{algorithm}
```

## System architecture

ANIME follows a multi-layered architecture with a high-performance Rust core focused on geometric matching, complemented by language-specific bindings that provide attribute interpolation utilities for broad accessibility across the geospatial community.

### Core components

**Rust Core Algorithm**: The high-performance engine is implemented in Rust and leverages R*-tree spatial indexing. Key components include:

- **Spatial Indexing Engine**: An R*-tree implementation for efficient geometric queries.
- **Geometric Processing**: Algorithms for `LineString` decomposition, slope calculation, and shared length computation.

### Data structures

ANIME's implementation is built around several key data structures that enable efficient spatial matching and interpolation.

**Core Anime Struct**

The `Anime` struct serves as the central coordinator for the entire matching and interpolation process, maintaining spatial indices, tolerance parameters, feature lengths, and computed matches:

$$\text{Anime} = \{Tree_A, Tree_B, DT, AT, L_A, L_B, \text{matches}\} \tag{4}$$

where $Tree_A$ and $Tree_B$ are the source and target R*-trees, $DT$ is the distance tolerance, $AT$ is the angle tolerance, $L_A$ and $L_B$ are vectors storing the lengths of source and target features respectively, and $\text{matches}$ stores the computed correspondences.

**Target Line Structure**

The target line structure represents `LineString` components with automatic distance buffering, mathematically defined as:

$$\text{TarLine} = (L_{segment}, DT) \tag{5}$$

where $L_{segment}$ is the geometric line segment and $DT$ is the distance tolerance for spatial buffering.

**Match Candidate Structure**

Each potential match is represented by a `MatchCandidate` struct that stores the relationship between source and target segments:

$$\text{MatchCandidate} = \{\text{source\_index}, \text{shared\_len}\} \tag{6}$$

where $\text{source\_index}$ identifies the source geometry and $\text{shared\_len}$ quantifies the geometric overlap.

**Key Operations**:

- **Slope Calculation**: 
  $$m = \frac{y_2 - y_1}{x_2 - x_1} \tag{7}$$
- **Angle Calculation**: 
  $$\theta = \arctan(m) \tag{8}$$
- **Angle Tolerance Test**:
  $$|\theta_A - \theta_B| < AT \tag{9}$$
- **Envelope Expansion**:
  $$\text{AABB}_{expanded} = [x_{\min} - DT, x_{\max} + DT] \times [y_{\min} - DT, y_{\max} + DT] \tag{10}$$
- **Distance Calculation**:
  $$d(L_1, L_2) = \min_{p_1 \in L_1, p_2 \in L_2} ||p_1 - p_2||_2 \tag{11}$$

**Spatial Index Types**

The spatial indexing system employs two R*-trees with mathematical structure:

**Source Tree**:
$$Tree_A = \{(L_{ik}, i, m_{ik}, \text{AABB}_{ik}) : L_{ik} \in A\} \tag{12}$$

**Target Tree**:
$$Tree_B = \{(L_{jk}, j, m_{jk}, \text{AABB}_{jk}^{\text{expanded}}) : L_{jk} \in B\} \tag{13}$$

where $L_{ik}$ is the line segment $k$ of `LineString` $i$, $m_{ik} = \frac{\Delta y}{\Delta x}$ is the computed slope, $\text{AABB}_{ik}$ is the axis-aligned bounding box, and $\text{AABB}_{jk}^{\text{expanded}}$ is the distance-buffered bounding box.

## Geometric processing implementation

### Overlap range calculation

The 1D overlap between two ranges is mathematically determined by:

$$\text{overlap}(R_1, R_2) = \begin{cases}
[\max(r_{1,\min}, r_{2,\min}), \min(r_{1,\max}, r_{2,\max})] & \text{if } r_{1,\max} \geq r_{2,\min} \text{ and } r_{2,\max} \geq r_{1,\min} \\
\emptyset & \text{otherwise}
\end{cases} \tag{14}$$

where $R_1 = [r_{1,\min}, r_{1,\max}]$ and $R_2 = [r_{2,\min}, r_{2,\max}]$ represent the ranges in either x or y dimension.

### Line intersection solving

For a line segment with slope $m$ passing through point $(x_0, y_0)$, the line equation is:
$$y = mx + b \quad \text{where } b = y_0 - mx_0 \tag{15}$$

**X-Dimension Overlap Solution**:
Given x-range overlap $[x_{\min}, x_{\max}]$, the corresponding y-coordinates are:
$$y_1 = mx_{\min} + b, \quad y_2 = mx_{\max} + b \tag{16}$$
$$\text{Points: } P_1 = (x_{\min}, y_1), \quad P_2 = (x_{\max}, y_2) \tag{17}$$

**Y-Dimension Overlap Solution**:
Given y-range overlap $[y_{\min}, y_{\max}]$, the corresponding x-coordinates are:
$$x_1 = \begin{cases}
\frac{y_{\min} - b}{m} & \text{if } m \neq 0, \infty \\
x_0 & \text{if } m = \infty \text{ (vertical line)}
\end{cases} \tag{18}  $$
$$x_2 = \begin{cases}
\frac{y_{\max} - b}{m} & \text{if } m \neq 0, \infty \\
x_0 & \text{if } m = \infty \text{ (vertical line)}
\end{cases} \tag{19}$$
$$\text{Points: } P_1 = (x_1, y_{\min}), \quad P_2 = (x_2, y_{\max}) \tag{20}$$

## Attribute interpolation implementation

The interpolation system implements the mathematical methods described in Section 2.3 using efficient Rust algorithms. The implementation provides robust handling of edge cases and optimized data structures for large-scale attribute transfer.

### Implementation architecture

The interpolation engine is built around the following key components:

- **Input Validation**: Ensures attribute arrays match the expected dimensions and data types
- **Missing Value Handling**: Automatically excludes NaN and null values (represented as `f64::MAX`) from calculations, skipping these entries during weighted aggregation
- **Memory Management**: Uses efficient data structures (BTreeMap) for storing and retrieving match relationships
- **Numerical Stability**: Implements robust arithmetic operations to handle edge cases

### Extensive interpolation implementation

The extensive interpolation engine (implementing @eq-extensive) performs length-weighted distribution of source attributes:

- **Input**: Source attribute vector and computed match matrix with shared lengths
- **Processing**: Calculates proportional weights $w_{ij} = \frac{SL_{ij}}{\text{length}(i)}$ for each valid match
- **Output**: Aggregated values for each target feature
- **Edge Cases**: Handles zero-length segments and missing attribute values gracefully

### Intensive interpolation implementation  

The intensive interpolation engine (implementing @eq-intensive) computes length-weighted averages:

- **Input**: Source attribute vector and computed match matrix with shared lengths  
- **Processing**: Calculates weighted means using shared lengths as weights
- **Output**: Averaged values for each target feature based on geometric correspondence
- **Edge Cases**: Returns zero for targets with no valid matches or zero total shared length

## Performance optimizations

The ANIME algorithm incorporates several performance optimizations to ensure efficiency and scalability. These are categorized into spatial indexing, algorithmic, and memory management strategies:

- **Spatial Indexing**:
  
    - **R*-tree Spatial Indexing**: Reduces query complexity from O(n²) to O(log n), enabling efficient candidate searches.
    - **Cached Envelopes**: Pre-computes and caches bounding boxes to accelerate geometric queries.
    - **Buffer Strategy**: Expands target geometry envelopes by the distance tolerance, streamlining the identification of proximal candidates.

- **Algorithmic Strategies**:

    - **Early Filtering**: Applies inexpensive angle and distance checks to prune candidate pairs before performing complex overlap calculations.
    - **Segment-Level Processing**: Decomposes `LineString` geometries into individual segments for granular matching, avoiding computationally intensive comparisons of entire features.
    - **OnceCell Pattern**: Caches match results to prevent redundant computations for the same feature pairs.
  
- **Memory Management**:
  
    - **BTreeMap Storage**: Employs efficient, sorted data structures for organizing and looking up matches.
    - **Streaming Processing**: Designed to handle large datasets that may not fit into memory.

The overall complexity of the ANIME algorithm is dominated by the R-tree construction and query operations. The time complexity is O(n log n + mk) and the space complexity is O(n + m), where $n$ is the number of source segments, $m$ is the number of target segments, and $k$ is the average number of candidates per query. The following table summarizes the time and space complexity of key operations.

| Operation             | Time Complexity | Space Complexity |
| --------------------- | --------------- | ---------------- |
| R-tree Construction   | O(n log n)      | O(n)             |
| Spatial Query         | O(log n + k)    | O(1)             |
| Angle Comparison      | O(1)            | O(1)             |
| Overlap Calculation   | O(1)            | O(1)             |
| **Overall Algorithm** | O(n log n + mk) | O(n + m)         |

: Time and space complexity of key operations.


## Language bindings architecture

ANIME is designed with a core Rust engine and a language-agnostic architecture to ensure broad accessibility. High-performance bindings for R and Python are provided, maintaining consistent algorithmic behavior and performance across environments.

**R Package Integration**: The R package (`anime`) leverages several key technologies for seamless integration:

- **extendr**: Provides the framework for Rust-R bindings and package compilation.
- **geoarrow**: Enables efficient, zero-copy columnar geometry processing based on the GeoArrow specification.
- **arrow/nanoarrow**: Used for columnar data exchange and memory management.
- **wk**: Facilitates well-known geometry handling and primitive operations.

**Python Package Integration**: The Python bindings (`anime`) use a similar high-performance stack:

- **PyO3**: The primary library for creating robust Rust-Python bindings.
- **geoarrow-rust**: Provides native Arrow-based geometry handling for efficient data interchange.
- **numpy**: Ensures compatibility with the standard numerical array processing library in Python.

This architecture ensures that users in both ecosystems can benefit from the performance of the core Rust implementation while working with idiomatic interfaces and data structures.

# Case Study

This section demonstrates ANIME's practical application and scalability through a comprehensive case study utilizing multiple national transportation datasets.
The experimental design involves matching source networks from the NPTScot (Network Planning Tool Scotland) project and OpenStreetMap (OSM) to the Ordnance Survey (OS) Open Road network (target), representing a realistic large-scale multi-source conflation scenario characteristic of national transport planning applications.

The case study evaluates ANIME's capability across four distinct attribute types that collectively demonstrate the algorithm's versatility across data integration scenarios:

1. **Go Dutch cycling potential (extensive variable)**: Cycling flow volumes from the NPT project under a hypothetical policy scenario, evaluating ANIME's capacity to aggregate values from multiple source features to single target features (n:1 relationships) through length-weighted summation.

2. **Bus route presence (binary categorical)**: Binary indicators from OSM data identifying road segments serving as bus routes, examining ANIME's capability to transfer categorical data and compute proportional representations for mixed-category target features.

3. **Number of bus lanes (intensive numeric)**: Counts of dedicated bus lanes per road segment from OSM data, assessing ANIME's capacity to compute length-weighted averages when transferring mean values from multiple source features to single target features (n:1 relationships).

4. **Speed limit (discrete numeric)**: Posted speed limits from OSM data, evaluating ANIME's capability to handle discrete numerical values and compute appropriate weighted averages for target features.

The source networks exhibit complex geometric representations, with OSM employing separate `LineString` geometries for each side of a street and individual lines for cycling pavements and dedicated lanes. In contrast, the target network (OS Open Roads) utilizes simplified geometry, representing each street as a single `LineString` regardless of lane count or adjacent infrastructure.
This configuration evaluates ANIME's capacity to handle complex-to-simplified matching across multiple data sources simultaneously, requiring aggregation from detailed geometric representations to generalized network structures: a challenging scenario that traditional conflation approaches struggle to address comprehensively.

## Parameter selection guidance

Effective application of ANIME requires appropriate selection of the `distance_tolerance` and `angle_tolerance` parameters based on input data characteristics. @tbl-parameter-guidance provides recommended parameter ranges for common use cases.

| Data Quality | Distance Tolerance | Angle Tolerance | Typical Applications |
|--------------|-------------------|-----------------|---------------------|
| High-precision surveyed | 2–5 m | 5–10° | Authoritative government datasets |
| Crowd-sourced (OSM) | 5–10 m | 10–15° | OpenStreetMap, VGI sources |
| Digitized historical | 10–20 m | 15–25° | Scanned maps, legacy datasets |
| Mixed-source integration | 10–15 m | 10–20° | Multi-agency conflation |

: Parameter selection guidance based on data quality and application context. {#tbl-parameter-guidance}

**Distance tolerance** controls the maximum separation between line segments considered for matching. Lower values increase precision but may miss valid matches in geometrically imprecise datasets. Higher values improve recall but risk false positives from nearby parallel features.

**Angle tolerance** determines the maximum angular difference between segments considered parallel. Organic street patterns (e.g., historic city centers) typically require larger tolerances than regular grid networks.

For the Edinburgh case study, parameters of `distance_tolerance = 15m` and `angle_tolerance = 5°` were selected based on the moderate geometric precision of OSM data and the predominantly regular street grid pattern.

## Illustrative example: ANIME functionality demonstration

To demonstrate ANIME's core functionality, this section presents a simple illustrative example demonstrating how the algorithm identifies and quantifies geometric relationships between source and target features.

```{r}
#| label: setup-case-study
#| include: false
suppressMessages(library(sf))
suppressMessages(library(dplyr))
suppressMessages(library(ggplot2))

# Load source and target data
crop_box <- st_bbox(c("xmin" = 427200, xmax = 427500, ymin = 433550, ymax = 433700))

target_sf <- "https://raw.githubusercontent.com/nptscot/networkmerge/main/data/rnet_armley.geojson" |>
  read_sf() |>
  st_geometry() |>
  st_transform(27700) |>
  st_crop(crop_box) |>
  st_sf()

source_sf <- "https://raw.githubusercontent.com/nptscot/networkmerge/main/data/rnet_armley_line.geojson" |>
  read_sf() |>
  st_crop(crop_box) |>
  st_transform(27700)

# Add attributes to the source data for integration
set.seed(123)
source_sf$speed_limit <- sample(c(20, 30, 40), nrow(source_sf), replace = TRUE)
source_sf$road_type <- sample(c("residential", "primary"), nrow(source_sf), replace = TRUE)
source_sf$source_id <- 1:nrow(source_sf)

# Run ANIME
match_matrix <- anime::anime(
  source_sf,
  target_sf,
  distance_tolerance = 2.5,
  angle_tolerance = 15
)

match_df <- as.data.frame(match_matrix)

# Perform attribute integration
match_df_attr <- merge(match_df, st_drop_geometry(source_sf), by = "source_id")

# Intensive numeric integration
intensive_numeric <- match_df_attr |>
  group_by(target_id) |>
  summarise(
    speed_limit_integrated = sum(shared_len * speed_limit) / sum(shared_len)
  )

# Intensive categorical integration
road_type_dummies <- model.matrix(~ road_type - 1, data = match_df_attr)
match_df_attr_dummies <- cbind(match_df_attr, road_type_dummies)

intensive_categorical <- match_df_attr_dummies |>
  group_by(target_id) |>
  summarise(
    residential_prop = sum(shared_len * road_typeresidential) / sum(shared_len),
    primary_prop = sum(shared_len * road_typeprimary) / sum(shared_len)
  )

# Combine results
target_sf$target_id <- 1:nrow(target_sf)
integrated_sf <- merge(target_sf, intensive_numeric, by = "target_id", all.x = TRUE)
integrated_sf <- merge(integrated_sf, intensive_categorical, by = "target_id", all.x = TRUE)
```

@fig-plot-matches illustrates ANIME's approach to complex-to-simplified geometric matching, wherein multiple detailed source features (red, solid lines) are matched to a single generalized target feature (blue, dashed line). Each source feature contributes varying amounts of shared length to the target, demonstrating ANIME's quantitative correspondence measurement approach rather than binary matching decisions. This many-to-one scenario represents typical conditions when conflating detailed OSM geometries with simplified reference networks.

```{r}
#| label: fig-plot-matches
#| fig-cap: "Complex-to-simplified matching example: multiple source features (red, solid) matched to single target feature (blue, dashed) with varying shared lengths. Parameters: distance_tolerance = 2.5m, angle_tolerance = 15°."
#| echo: false
i <- 4
target_feature <- target_sf[i,]
source_indices <- match_df$source_id[match_df$target_id == i]
source_features <- source_sf[source_indices,]

ggplot() +
  geom_sf(data = source_features, color = "red", linewidth = 1) +
  geom_sf(data = target_feature, linetype = "dashed", color = "blue", linewidth = 1.2) +
  theme_void()
```

The underlying data structure produced by ANIME contains detailed correspondence information for every matched pair. @tbl-match-results presents a sample of the matching output, wherein each row represents a source-target pair with its corresponding shared length ($SL_{ij}$). This quantitative foundation enables robust weighted attribute transfer utilizing the mathematical methods described in Section 2.3.

```{r}
#| label: tbl-match-results
#| echo: false
knitr::kable(
  head(match_df),
  caption = "Sample of matched pairs with shared length."
)
```

## National-scale results: Comprehensive four-attribute integration

Building upon this illustrative example, this section presents results from comprehensive national-scale analysis demonstrating ANIME's capability across four distinct attribute types. For comparison purposes, only the city centre of Edinburgh is shown below.

![Data transfer comparison in central Edinburgh (Parameters: distance_tolerance = 15m, angle_tolerance = 5°)](assets/data_transfer_comparison_plot.png){#fig-data-transfer-comparison}

@fig-data-transfer-comparison presents outputs from the four-attribute integration in central Edinburgh computed using **ANIME**. The visualization illustrates length-weighted aggregation (Go Dutch cycling potential), proportional categorical transfer (bus route presence), intensive numeric averaging (bus lane counts), and discrete value interpolation (speed limits). Interactive web maps containing complete Scottish road network outputs for each attribute type can be explored at <https://nptscot.github.io/>.

The example highlights ANIME's core strength in quantifying **degrees of correspondence** rather than making binary matching decisions, enabling integration across n:1 and m:n relationships encountered in practice.


# Discussion

The case study illustrates how ANIME can address key limitations of existing network conflation approaches.
Across the studied networks, ANIME identified and quantified complex geometric relationships between topologically dissimilar representations and produced weighted correspondence metrics suitable for length-weighted attribute transfer.
The following analysis highlights key algorithmic properties illustrated:

**M:N Relationship Handling**: The results demonstrate ANIME's robust handling of one-to-many and many-to-one correspondences, wherein single features in one dataset match multiple features in another.
This capability proves essential for real-world conflation scenarios where `LineString` representations differ in geometric complexity and feature granularity.
While recent methods such as Voronoi-based approaches [@wu_voronoi_2023] and subgraph growing algorithms [@nguyen_apsg_2022] also support m:n matching, ANIME uniquely provides quantitative overlap measures rather than binary match decisions.

**Quantitative Correspondence Assessment**: Unlike binary matching approaches, ANIME quantifies precise degrees of overlap between `LineString` features through shared length calculations.
This enables nuanced decision-making regarding match quality and provides mathematical foundation for weighted attribute integration.
Traditional similarity measures catalogued in prior surveys [@xavier_survey_2016] provide match scores but not proportional overlap values suitable for attribute apportionment.

**Weighted Attribute Integration**: The successful transfer of both numeric (speed_limit) and categorical (road_type) attributes demonstrates practical utility of ANIME's extensive and intensive interpolation methods.
The algorithm maintains statistical rigor by appropriately weighting contributions based on geometric correspondence, ensuring that attribute values reflect spatial extent of matching relationships.
This approach builds on established areal interpolation principles [@comber_spatial_2019] and extends the flow aggregation concepts demonstrated by @morgan_travel_2021 to arbitrary network conflation scenarios.

## Limitations and boundary conditions

While ANIME demonstrates robust performance across the tested scenarios, several limitations warrant consideration for practitioners and future development.

### Geometric constraints

**Highly curved roads**: The segment-level decomposition assumes relatively straight line segments between vertices. Roads with tight curves (radius < 50m) may require higher vertex density for accurate matching. Practitioners should consider densifying vertices for curved features using standard geometry-processing libraries (e.g., sf/GEOS/GDAL in R or GeoPandas/Shapely in Python) prior to matching.

**Elevation considerations**: The current implementation operates in 2D planar space. Networks with significant elevation changes, such as mountain roads, overpasses, or multi-level interchanges, may produce spurious matches between vertically separated but horizontally proximate features. For current applications, practitioners can filter matches using elevation attributes if available.

**Topological complexity**: Junction areas with multiple converging roads present challenges for segment-level matching. Post-processing using network topology analysis can help resolve ambiguous matches in these areas.

**Topological errors**: Input networks with gaps (undershoots), overlaps (overshoots), or self-intersections may produce unexpected matches. Preprocessing with topology validation tools is recommended.

**Semantic ambiguity**: Purely geometric matching cannot resolve cases where geometric similarity exists but semantic meaning differs. Examples include parallel roads at different elevations (highway/frontage road), separate bicycle paths adjacent to roads, and service roads parallel to main thoroughfares. Integration of semantic attributes in post-processing can help resolve these ambiguities.

### Computational considerations

**Real-time applications**: Current processing rates are suitable for batch processing but may be insufficient for real-time applications requiring sub-second response times.

## Applications and use cases

The flexibility of ANIME enables diverse applications across spatial data science domains.

**Transport Planning:**

- Integration of road networks from multiple sources for comprehensive transportation analysis
- Conflation of historical and current road datasets for temporal analysis
- Matching of planned versus existing infrastructure for impact assessment

**River Network Analysis:**

- Reconciliation of hydrographic datasets from different mapping agencies
- Integration of modeled and observed stream networks for ecological studies
- Conflation of networks at different scales for multi-resolution analysis

**Ecological Modeling:**

- Matching of habitat corridors from different data sources
- Integration of species movement pathways with landscape features
- Conflation of ecological networks for conservation planning

**Infrastructure Management:**

- Utility network integration for comprehensive asset management
- Conflation of as-built versus design datasets for infrastructure monitoring
- Integration of sensor networks with physical infrastructure representations


## Future development directions

Future work could extend the capabilities of the algorithm in several key areas.

**3D and Spherical Extensions:**

- Extension to three-dimensional coordinate systems incorporating elevation data
- Development of spherical geometry support for global-scale network analysis
- Integration with 3D city models and Building Information Modeling (BIM) systems

**Enhanced Geometric Processing:**

- Implementation of additional shape similarity measures beyond angle-based matching
- Support for curved `LineString` matching utilizing advanced geometric algorithms
- Integration of topology-aware matching for complex network structures

**Performance Optimization:**

- Parallel processing capabilities for large-scale network conflation
- Streaming algorithms for processing networks exceeding available memory
- GPU acceleration for computationally intensive geometric operations

# Conclusion

This paper introduced ANIME (Approximate Network Integration, Matching and Enrichment), a segment-level approach to network conflation that measures correspondence between linear features using shared length. By moving beyond binary matching decisions, ANIME supports partial correspondences and length-weighted attribute transfer for topologically dissimilar `LineString` datasets.

ANIME's core contributions represent significant advances in both theoretical foundation and practical implementation:

- **Quantitative Correspondence Framework**: The segment-level decomposition and shared length computation ($SL_{ij}$) enable precise measurement of partial overlaps, supporting complex m:n relationships that binary approaches cannot represent. Weighted proportions ($sw_{ij}$, $tw_{ij}$) can be derived on-demand for flexible attribute interpolation applications.

- **Mathematical Rigor**: Grounding attribute integration in established spatial interpolation theory ensures statistical validity for both extensive and intensive variables, providing a sound theoretical foundation for weighted aggregation.

- **Computational Implementation**: The high-performance Rust implementation with R*-tree spatial indexing and cross-language bindings demonstrates how modern systems programming can enhance geospatial workflows while maintaining broad accessibility.

- **Geometric Robustness**: Orientation-dependent overlap calculations ensure numerical stability across all segment orientations, addressing practical challenges in real-world geometric processing.

# Data Availability Statement {.unnumbered}

The datasets used in this study are publicly available from the following sources:

- **Ordnance Survey Open Roads**: Available from Ordnance Survey Open Data portal under the Open Government Licence v3.0 (<https://www.ordnancesurvey.co.uk/opendatadownload>).
- **NPTScot Network Data**: Available from the Network Planning Tool Scotland repository (<https://github.com/nptscot/networkmerge>) under MIT License.
- **OpenStreetMap Data**: Downloaded via Overpass API for Scotland. OpenStreetMap data is available under the Open Database License (<https://www.openstreetmap.org/copyright>).

All scripts used to download, preprocess, and analyze the data for this manuscript are available at <https://github.com/JosiahParry/anime> (see `paper/README.qmd` and `paper/REPRODUCE.md`).

# Code Availability Statement {.unnumbered}

The ANIME algorithm is implemented as open-source software under the MIT License:

- **Repository (Rust core, bindings, manuscript)**: <https://github.com/JosiahParry/anime>
- **Rust Core Library**: `rust/` (crate documentation: <https://docs.rs/anime/>)
- **R Bindings**: `r/` (see `r/README.md`)
- **Python Bindings**: `py/` (see `py/README.md`)

All analysis code for this manuscript is available at <https://github.com/JosiahParry/anime> with detailed reproduction instructions.

# References

::: {#refs}
:::
